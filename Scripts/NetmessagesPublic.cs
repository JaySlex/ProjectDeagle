// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: netmessages_public.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public static partial class NetmessagesPublic {

  #region Descriptor
  public static pbr::FileDescriptor Descriptor {
    get { return descriptor; }
  }
  private static pbr::FileDescriptor descriptor;

  static NetmessagesPublic() {
    byte[] descriptorData = global::System.Convert.FromBase64String(
        string.Concat(
          "ChhuZXRtZXNzYWdlc19wdWJsaWMucHJvdG8iLQoKQ01zZ1ZlY3RvchIJCgF4", 
          "GAEgASgCEgkKAXkYAiABKAISCQoBehgDIAEoAiIkCgxDTXNnVmVjdG9yMkQS", 
          "CQoBeBgBIAEoAhIJCgF5GAIgASgCIi0KCkNNc2dRQW5nbGUSCQoBeBgBIAEo", 
          "AhIJCgF5GAIgASgCEgkKAXoYAyABKAIiNgoIQ01zZ1JHQkESCQoBchgBIAEo", 
          "BRIJCgFnGAIgASgFEgkKAWIYAyABKAUSCQoBYRgEIAEoBSKRAQoMQ05FVE1z", 
          "Z19UaWNrEgwKBHRpY2sYASABKA0SHAoUaG9zdF9jb21wdXRhdGlvbnRpbWUY", 
          "BCABKA0SKgoiaG9zdF9jb21wdXRhdGlvbnRpbWVfc3RkX2RldmlhdGlvbhgF", 
          "IAEoDRIpCiFob3N0X2ZyYW1lc3RhcnR0aW1lX3N0ZF9kZXZpYXRpb24YBiAB", 
          "KA0iJAoRQ05FVE1zZ19TdHJpbmdDbWQSDwoHY29tbWFuZBgBIAEoCSKKAQoT", 
          "Q05FVE1zZ19TaWdub25TdGF0ZRIUCgxzaWdub25fc3RhdGUYASABKA0SEwoL", 
          "c3Bhd25fY291bnQYAiABKA0SGgoSbnVtX3NlcnZlcl9wbGF5ZXJzGAMgASgN", 
          "EhoKEnBsYXllcnNfbmV0d29ya2lkcxgEIAMoCRIQCghtYXBfbmFtZRgFIAEo", 
          "CSJSCgpDTXNnX0NWYXJzEh8KBWN2YXJzGAEgAygLMhAuQ01zZ19DVmFycy5D", 
          "VmFyGiMKBENWYXISDAoEbmFtZRgBIAEoCRINCgV2YWx1ZRgCIAEoCSIxChFD", 
          "TkVUTXNnX1NldENvblZhchIcCgdjb252YXJzGAEgASgLMgsuQ01zZ19DVmFy", 
          "cyINCgtDTkVUTXNnX05PUCIiChJDTkVUTXNnX0Rpc2Nvbm5lY3QSDAoEdGV4", 
          "dBgBIAEoCSJhCgxDTkVUTXNnX0ZpbGUSEwoLdHJhbnNmZXJfaWQYASABKAUS", 
          "EQoJZmlsZV9uYW1lGAIgASgJEhsKE2lzX3JlcGxheV9kZW1vX2ZpbGUYAyAB", 
          "KAgSDAoEZGVueRgEIAEoCCLXAwoSQ1NWQ01zZ19TZXJ2ZXJJbmZvEhAKCHBy", 
          "b3RvY29sGAEgASgFEhQKDHNlcnZlcl9jb3VudBgCIAEoBRIUCgxpc19kZWRp", 
          "Y2F0ZWQYAyABKAgSIAoYaXNfb2ZmaWNpYWxfdmFsdmVfc2VydmVyGAQgASgI", 
          "Eg8KB2lzX2hsdHYYBSABKAgSEQoJaXNfcmVwbGF5GAYgASgIEiUKHWlzX3Jl", 
          "ZGlyZWN0aW5nX3RvX3Byb3h5X3JlbGF5GBUgASgIEgwKBGNfb3MYByABKAUS", 
          "DwoHbWFwX2NyYxgIIAEoBxISCgpjbGllbnRfY3JjGAkgASgHEhgKEHN0cmlu", 
          "Z190YWJsZV9jcmMYCiABKAcSEwoLbWF4X2NsaWVudHMYCyABKAUSEwoLbWF4", 
          "X2NsYXNzZXMYDCABKAUSEwoLcGxheWVyX3Nsb3QYDSABKAUSFQoNdGlja19p", 
          "bnRlcnZhbBgOIAEoAhIQCghnYW1lX2RpchgPIAEoCRIQCghtYXBfbmFtZRgQ", 
          "IAEoCRIWCg5tYXBfZ3JvdXBfbmFtZRgRIAEoCRIQCghza3lfbmFtZRgSIAEo", 
          "CRIRCglob3N0X25hbWUYEyABKAkSEgoKdWdjX21hcF9pZBgWIAEoBCKkAQoR", 
          "Q1NWQ01zZ19DbGFzc0luZm8SGAoQY3JlYXRlX29uX2NsaWVudBgBIAEoCBIr", 
          "CgdjbGFzc2VzGAIgAygLMhouQ1NWQ01zZ19DbGFzc0luZm8uY2xhc3NfdBpI", 
          "CgdjbGFzc190EhAKCGNsYXNzX2lkGAEgASgFEhcKD2RhdGFfdGFibGVfbmFt", 
          "ZRgCIAEoCRISCgpjbGFzc19uYW1lGAMgASgJIrACChFDU1ZDTXNnX1NlbmRU", 
          "YWJsZRIOCgZpc19lbmQYASABKAgSFgoObmV0X3RhYmxlX25hbWUYAiABKAkS", 
          "FQoNbmVlZHNfZGVjb2RlchgDIAEoCBIsCgVwcm9wcxgEIAMoCzIdLkNTVkNN", 
          "c2dfU2VuZFRhYmxlLnNlbmRwcm9wX3QarQEKCnNlbmRwcm9wX3QSDAoEdHlw", 
          "ZRgBIAEoBRIQCgh2YXJfbmFtZRgCIAEoCRINCgVmbGFncxgDIAEoBRIQCghw", 
          "cmlvcml0eRgEIAEoBRIPCgdkdF9uYW1lGAUgASgJEhQKDG51bV9lbGVtZW50", 
          "cxgGIAEoBRIRCglsb3dfdmFsdWUYByABKAISEgoKaGlnaF92YWx1ZRgIIAEo", 
          "AhIQCghudW1fYml0cxgJIAEoBSIdCg1DU1ZDTXNnX1ByaW50EgwKBHRleHQY", 
          "ASABKAkiIgoQQ1NWQ01zZ19TZXRQYXVzZRIOCgZwYXVzZWQYASABKAgiJwoP", 
          "Q1NWQ01zZ19TZXRWaWV3EhQKDGVudGl0eV9pbmRleBgBIAEoBSLKAQoZQ1NW", 
          "Q01zZ19DcmVhdGVTdHJpbmdUYWJsZRIMCgRuYW1lGAEgASgJEhMKC21heF9l", 
          "bnRyaWVzGAIgASgFEhMKC251bV9lbnRyaWVzGAMgASgFEhwKFHVzZXJfZGF0", 
          "YV9maXhlZF9zaXplGAQgASgIEhYKDnVzZXJfZGF0YV9zaXplGAUgASgFEhsK", 
          "E3VzZXJfZGF0YV9zaXplX2JpdHMYBiABKAUSDQoFZmxhZ3MYByABKAUSEwoL", 
          "c3RyaW5nX2RhdGEYCCABKAwiXwoZQ1NWQ01zZ19VcGRhdGVTdHJpbmdUYWJs", 
          "ZRIQCgh0YWJsZV9pZBgBIAEoBRIbChNudW1fY2hhbmdlZF9lbnRyaWVzGAIg", 
          "ASgFEhMKC3N0cmluZ19kYXRhGAMgASgMIjMKEUNTVkNNc2dfVm9pY2VJbml0", 
          "Eg8KB3F1YWxpdHkYASABKAUSDQoFY29kZWMYAiABKAkibgoRQ1NWQ01zZ19W", 
          "b2ljZURhdGESDgoGY2xpZW50GAEgASgFEhEKCXByb3hpbWl0eRgCIAEoCBIM", 
          "CgR4dWlkGAMgASgGEhQKDGF1ZGlibGVfbWFzaxgEIAEoBRISCgp2b2ljZV9k", 
          "YXRhGAUgASgMIkAKEENTVkNNc2dfRml4QW5nbGUSEAoIcmVsYXRpdmUYASAB", 
          "KAgSGgoFYW5nbGUYAiABKAsyCy5DTXNnUUFuZ2xlIjQKFkNTVkNNc2dfQ3Jv", 
          "c3NoYWlyQW5nbGUSGgoFYW5nbGUYASABKAsyCy5DTXNnUUFuZ2xlIicKEENT", 
          "VkNNc2dfUHJlZmV0Y2gSEwoLc291bmRfaW5kZXgYASABKAUiigEKEENTVkNN", 
          "c2dfQlNQRGVjYWwSGAoDcG9zGAEgASgLMgsuQ01zZ1ZlY3RvchIbChNkZWNh", 
          "bF90ZXh0dXJlX2luZGV4GAIgASgFEhQKDGVudGl0eV9pbmRleBgDIAEoBRIT", 
          "Cgttb2RlbF9pbmRleBgEIAEoBRIUCgxsb3dfcHJpb3JpdHkYBSABKAgiOQoU", 
          "Q1NWQ01zZ19HZXRDdmFyVmFsdWUSDgoGY29va2llGAEgASgFEhEKCWN2YXJf", 
          "bmFtZRgCIAEoCSI8CgxDU1ZDTXNnX01lbnUSEwoLZGlhbG9nX3R5cGUYASAB", 
          "KAUSFwoPbWVudV9rZXlfdmFsdWVzGAIgASgMIjkKE0NTVkNNc2dfVXNlck1l", 
          "c3NhZ2USEAoIbXNnX3R5cGUYASABKAUSEAoIbXNnX2RhdGEYAiABKAwikQIK", 
          "EUNTVkNNc2dfR2FtZUV2ZW50EhIKCmV2ZW50X25hbWUYASABKAkSDwoHZXZl", 
          "bnRpZBgCIAEoBRImCgRrZXlzGAMgAygLMhguQ1NWQ01zZ19HYW1lRXZlbnQu", 
          "a2V5X3QargEKBWtleV90EgwKBHR5cGUYASABKAUSEgoKdmFsX3N0cmluZxgC", 
          "IAEoCRIRCgl2YWxfZmxvYXQYAyABKAISEAoIdmFsX2xvbmcYBCABKAUSEQoJ", 
          "dmFsX3Nob3J0GAUgASgFEhAKCHZhbF9ieXRlGAYgASgFEhAKCHZhbF9ib29s", 
          "GAcgASgIEhIKCnZhbF91aW50NjQYCCABKAQSEwoLdmFsX3dzdHJpbmcYCSAB", 
          "KAwi0QEKFUNTVkNNc2dfR2FtZUV2ZW50TGlzdBI4CgtkZXNjcmlwdG9ycxgB", 
          "IAMoCzIjLkNTVkNNc2dfR2FtZUV2ZW50TGlzdC5kZXNjcmlwdG9yX3QaIwoF", 
          "a2V5X3QSDAoEdHlwZRgBIAEoBRIMCgRuYW1lGAIgASgJGlkKDGRlc2NyaXB0", 
          "b3JfdBIPCgdldmVudGlkGAEgASgFEgwKBG5hbWUYAiABKAkSKgoEa2V5cxgD", 
          "IAMoCzIcLkNTVkNNc2dfR2FtZUV2ZW50TGlzdC5rZXlfdCJSChRDU1ZDTXNn", 
          "X1RlbXBFbnRpdGllcxIQCghyZWxpYWJsZRgBIAEoCBITCgtudW1fZW50cmll", 
          "cxgCIAEoBRITCgtlbnRpdHlfZGF0YRgDIAEoDCKsAQoWQ1NWQ01zZ19QYWNr", 
          "ZXRFbnRpdGllcxITCgttYXhfZW50cmllcxgBIAEoBRIXCg91cGRhdGVkX2Vu", 
          "dHJpZXMYAiABKAUSEAoIaXNfZGVsdGEYAyABKAgSFwoPdXBkYXRlX2Jhc2Vs", 
          "aW5lGAQgASgIEhAKCGJhc2VsaW5lGAUgASgFEhIKCmRlbHRhX2Zyb20YBiAB", 
          "KAUSEwoLZW50aXR5X2RhdGEYByABKAwitgMKDkNTVkNNc2dfU291bmRzEhYK", 
          "DnJlbGlhYmxlX3NvdW5kGAEgASgIEisKBnNvdW5kcxgCIAMoCzIbLkNTVkNN", 
          "c2dfU291bmRzLnNvdW5kZGF0YV90Gt4CCgtzb3VuZGRhdGFfdBIQCghvcmln", 
          "aW5feBgBIAEoERIQCghvcmlnaW5feRgCIAEoERIQCghvcmlnaW5fehgDIAEo", 
          "ERIOCgZ2b2x1bWUYBCABKA0SEwoLZGVsYXlfdmFsdWUYBSABKAISFwoPc2Vx", 
          "dWVuY2VfbnVtYmVyGAYgASgFEhQKDGVudGl0eV9pbmRleBgHIAEoBRIPCgdj", 
          "aGFubmVsGAggASgFEg0KBXBpdGNoGAkgASgFEg0KBWZsYWdzGAogASgFEhEK", 
          "CXNvdW5kX251bRgLIAEoDRIYChBzb3VuZF9udW1faGFuZGxlGAwgASgHEhYK", 
          "DnNwZWFrZXJfZW50aXR5GA0gASgFEhMKC3JhbmRvbV9zZWVkGA4gASgFEhMK", 
          "C3NvdW5kX2xldmVsGA8gASgFEhMKC2lzX3NlbnRlbmNlGBAgASgIEhIKCmlz", 
          "X2FtYmllbnQYESABKAgqhgEKDE5FVF9NZXNzYWdlcxILCgduZXRfTk9QEAAS", 
          "EgoObmV0X0Rpc2Nvbm5lY3QQARIMCghuZXRfRmlsZRACEgwKCG5ldF9UaWNr", 
          "EAQSEQoNbmV0X1N0cmluZ0NtZBAFEhEKDW5ldF9TZXRDb25WYXIQBhITCg9u", 
          "ZXRfU2lnbm9uU3RhdGUQByrQAwoMU1ZDX01lc3NhZ2VzEgkKBWVtcHR5EAAS", 
          "EgoOc3ZjX1NlcnZlckluZm8QCBIRCg1zdmNfU2VuZFRhYmxlEAkSEQoNc3Zj", 
          "X0NsYXNzSW5mbxAKEhAKDHN2Y19TZXRQYXVzZRALEhkKFXN2Y19DcmVhdGVT", 
          "dHJpbmdUYWJsZRAMEhkKFXN2Y19VcGRhdGVTdHJpbmdUYWJsZRANEhEKDXN2", 
          "Y19Wb2ljZUluaXQQDhIRCg1zdmNfVm9pY2VEYXRhEA8SDQoJc3ZjX1ByaW50", 
          "EBASDgoKc3ZjX1NvdW5kcxAREg8KC3N2Y19TZXRWaWV3EBISEAoMc3ZjX0Zp", 
          "eEFuZ2xlEBMSFgoSc3ZjX0Nyb3NzaGFpckFuZ2xlEBQSEAoMc3ZjX0JTUERl", 
          "Y2FsEBUSEwoPc3ZjX1VzZXJNZXNzYWdlEBcSEQoNc3ZjX0dhbWVFdmVudBAZ", 
          "EhYKEnN2Y19QYWNrZXRFbnRpdGllcxAaEhQKEHN2Y19UZW1wRW50aXRpZXMQ", 
          "GxIQCgxzdmNfUHJlZmV0Y2gQHBIMCghzdmNfTWVudRAdEhUKEXN2Y19HYW1l", 
          "RXZlbnRMaXN0EB4SFAoQc3ZjX0dldEN2YXJWYWx1ZRAfQgOAAQBiBnByb3Rv", 
          "Mw=="));
    descriptor = pbr::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
        new pbr::FileDescriptor[] { },
        new pbr::GeneratedCodeInfo(new[] {typeof(global::NET_Messages), typeof(global::SVC_Messages), }, new pbr::GeneratedCodeInfo[] {
          new pbr::GeneratedCodeInfo(typeof(global::CMsgVector), new[]{ "X", "Y", "Z" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CMsgVector2D), new[]{ "X", "Y" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CMsgQAngle), new[]{ "X", "Y", "Z" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CMsgRGBA), new[]{ "R", "G", "B", "A" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CNETMsg_Tick), new[]{ "Tick", "HostComputationtime", "HostComputationtimeStdDeviation", "HostFramestarttimeStdDeviation" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CNETMsg_StringCmd), new[]{ "Command" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CNETMsg_SignonState), new[]{ "SignonState", "SpawnCount", "NumServerPlayers", "PlayersNetworkids", "MapName" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CMsg_CVars), new[]{ "Cvars" }, null, null, new pbr::GeneratedCodeInfo[] { new pbr::GeneratedCodeInfo(typeof(global::CMsg_CVars.Types.CVar), new[]{ "Name", "Value" }, null, null, null)}),
          new pbr::GeneratedCodeInfo(typeof(global::CNETMsg_SetConVar), new[]{ "Convars" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CNETMsg_NOP), null, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CNETMsg_Disconnect), new[]{ "Text" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CNETMsg_File), new[]{ "TransferId", "FileName", "IsReplayDemoFile", "Deny" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_ServerInfo), new[]{ "Protocol", "ServerCount", "IsDedicated", "IsOfficialValveServer", "IsHltv", "IsReplay", "IsRedirectingToProxyRelay", "COs", "MapCrc", "ClientCrc", "StringTableCrc", "MaxClients", "MaxClasses", "PlayerSlot", "TickInterval", "GameDir", "MapName", "MapGroupName", "SkyName", "HostName", "UgcMapId" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_ClassInfo), new[]{ "CreateOnClient", "Classes" }, null, null, new pbr::GeneratedCodeInfo[] { new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_ClassInfo.Types.class_t), new[]{ "ClassId", "DataTableName", "ClassName" }, null, null, null)}),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_SendTable), new[]{ "IsEnd", "NetTableName", "NeedsDecoder", "Props" }, null, null, new pbr::GeneratedCodeInfo[] { new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_SendTable.Types.sendprop_t), new[]{ "Type", "VarName", "Flags", "Priority", "DtName", "NumElements", "LowValue", "HighValue", "NumBits" }, null, null, null)}),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_Print), new[]{ "Text" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_SetPause), new[]{ "Paused" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_SetView), new[]{ "EntityIndex" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_CreateStringTable), new[]{ "Name", "MaxEntries", "NumEntries", "UserDataFixedSize", "UserDataSize", "UserDataSizeBits", "Flags", "StringData" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_UpdateStringTable), new[]{ "TableId", "NumChangedEntries", "StringData" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_VoiceInit), new[]{ "Quality", "Codec" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_VoiceData), new[]{ "Client", "Proximity", "Xuid", "AudibleMask", "VoiceData" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_FixAngle), new[]{ "Relative", "Angle" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_CrosshairAngle), new[]{ "Angle" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_Prefetch), new[]{ "SoundIndex" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_BSPDecal), new[]{ "Pos", "DecalTextureIndex", "EntityIndex", "ModelIndex", "LowPriority" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_GetCvarValue), new[]{ "Cookie", "CvarName" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_Menu), new[]{ "DialogType", "MenuKeyValues" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_UserMessage), new[]{ "MsgType", "MsgData" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_GameEvent), new[]{ "EventName", "Eventid", "Keys" }, null, null, new pbr::GeneratedCodeInfo[] { new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_GameEvent.Types.key_t), new[]{ "Type", "ValString", "ValFloat", "ValLong", "ValShort", "ValByte", "ValBool", "ValUint64", "ValWstring" }, null, null, null)}),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_GameEventList), new[]{ "Descriptors" }, null, null, new pbr::GeneratedCodeInfo[] { new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_GameEventList.Types.key_t), new[]{ "Type", "Name" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_GameEventList.Types.descriptor_t), new[]{ "Eventid", "Name", "Keys" }, null, null, null)}),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_TempEntities), new[]{ "Reliable", "NumEntries", "EntityData" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_PacketEntities), new[]{ "MaxEntries", "UpdatedEntries", "IsDelta", "UpdateBaseline", "Baseline", "DeltaFrom", "EntityData" }, null, null, null),
          new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_Sounds), new[]{ "ReliableSound", "Sounds" }, null, null, new pbr::GeneratedCodeInfo[] { new pbr::GeneratedCodeInfo(typeof(global::CSVCMsg_Sounds.Types.sounddata_t), new[]{ "OriginX", "OriginY", "OriginZ", "Volume", "DelayValue", "SequenceNumber", "EntityIndex", "Channel", "Pitch", "Flags", "SoundNum", "SoundNumHandle", "SpeakerEntity", "RandomSeed", "SoundLevel", "IsSentence", "IsAmbient" }, null, null, null)})
        }));
  }
  #endregion

}
#region Enums
public enum NET_Messages {
  net_NOP = 0,
  net_Disconnect = 1,
  net_File = 2,
  net_Tick = 4,
  net_StringCmd = 5,
  net_SetConVar = 6,
  net_SignonState = 7,
}

public enum SVC_Messages {
  empty = 0,
  svc_ServerInfo = 8,
  svc_SendTable = 9,
  svc_ClassInfo = 10,
  svc_SetPause = 11,
  svc_CreateStringTable = 12,
  svc_UpdateStringTable = 13,
  svc_VoiceInit = 14,
  svc_VoiceData = 15,
  svc_Print = 16,
  svc_Sounds = 17,
  svc_SetView = 18,
  svc_FixAngle = 19,
  svc_CrosshairAngle = 20,
  svc_BSPDecal = 21,
  svc_UserMessage = 23,
  svc_GameEvent = 25,
  svc_PacketEntities = 26,
  svc_TempEntities = 27,
  svc_Prefetch = 28,
  svc_Menu = 29,
  svc_GameEventList = 30,
  svc_GetCvarValue = 31,
}

#endregion

#region Messages
[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CMsgVector : pb::IMessage<CMsgVector> {
  private static readonly pb::MessageParser<CMsgVector> _parser = new pb::MessageParser<CMsgVector>(() => new CMsgVector());
  public static pb::MessageParser<CMsgVector> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[0]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CMsgVector() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CMsgVector(CMsgVector other) : this() {
    x_ = other.x_;
    y_ = other.y_;
    z_ = other.z_;
  }

  public CMsgVector Clone() {
    return new CMsgVector(this);
  }

  public const int XFieldNumber = 1;
  private float x_;
  public float X {
    get { return x_; }
    set {
      x_ = value;
    }
  }

  public const int YFieldNumber = 2;
  private float y_;
  public float Y {
    get { return y_; }
    set {
      y_ = value;
    }
  }

  public const int ZFieldNumber = 3;
  private float z_;
  public float Z {
    get { return z_; }
    set {
      z_ = value;
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CMsgVector);
  }

  public bool Equals(CMsgVector other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (X != other.X) return false;
    if (Y != other.Y) return false;
    if (Z != other.Z) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (X != 0F) hash ^= X.GetHashCode();
    if (Y != 0F) hash ^= Y.GetHashCode();
    if (Z != 0F) hash ^= Z.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (X != 0F) {
      output.WriteRawTag(13);
      output.WriteFloat(X);
    }
    if (Y != 0F) {
      output.WriteRawTag(21);
      output.WriteFloat(Y);
    }
    if (Z != 0F) {
      output.WriteRawTag(29);
      output.WriteFloat(Z);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (X != 0F) {
      size += 1 + 4;
    }
    if (Y != 0F) {
      size += 1 + 4;
    }
    if (Z != 0F) {
      size += 1 + 4;
    }
    return size;
  }

  public void MergeFrom(CMsgVector other) {
    if (other == null) {
      return;
    }
    if (other.X != 0F) {
      X = other.X;
    }
    if (other.Y != 0F) {
      Y = other.Y;
    }
    if (other.Z != 0F) {
      Z = other.Z;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 13: {
          X = input.ReadFloat();
          break;
        }
        case 21: {
          Y = input.ReadFloat();
          break;
        }
        case 29: {
          Z = input.ReadFloat();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CMsgVector2D : pb::IMessage<CMsgVector2D> {
  private static readonly pb::MessageParser<CMsgVector2D> _parser = new pb::MessageParser<CMsgVector2D>(() => new CMsgVector2D());
  public static pb::MessageParser<CMsgVector2D> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[1]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CMsgVector2D() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CMsgVector2D(CMsgVector2D other) : this() {
    x_ = other.x_;
    y_ = other.y_;
  }

  public CMsgVector2D Clone() {
    return new CMsgVector2D(this);
  }

  public const int XFieldNumber = 1;
  private float x_;
  public float X {
    get { return x_; }
    set {
      x_ = value;
    }
  }

  public const int YFieldNumber = 2;
  private float y_;
  public float Y {
    get { return y_; }
    set {
      y_ = value;
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CMsgVector2D);
  }

  public bool Equals(CMsgVector2D other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (X != other.X) return false;
    if (Y != other.Y) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (X != 0F) hash ^= X.GetHashCode();
    if (Y != 0F) hash ^= Y.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (X != 0F) {
      output.WriteRawTag(13);
      output.WriteFloat(X);
    }
    if (Y != 0F) {
      output.WriteRawTag(21);
      output.WriteFloat(Y);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (X != 0F) {
      size += 1 + 4;
    }
    if (Y != 0F) {
      size += 1 + 4;
    }
    return size;
  }

  public void MergeFrom(CMsgVector2D other) {
    if (other == null) {
      return;
    }
    if (other.X != 0F) {
      X = other.X;
    }
    if (other.Y != 0F) {
      Y = other.Y;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 13: {
          X = input.ReadFloat();
          break;
        }
        case 21: {
          Y = input.ReadFloat();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CMsgQAngle : pb::IMessage<CMsgQAngle> {
  private static readonly pb::MessageParser<CMsgQAngle> _parser = new pb::MessageParser<CMsgQAngle>(() => new CMsgQAngle());
  public static pb::MessageParser<CMsgQAngle> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[2]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CMsgQAngle() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CMsgQAngle(CMsgQAngle other) : this() {
    x_ = other.x_;
    y_ = other.y_;
    z_ = other.z_;
  }

  public CMsgQAngle Clone() {
    return new CMsgQAngle(this);
  }

  public const int XFieldNumber = 1;
  private float x_;
  public float X {
    get { return x_; }
    set {
      x_ = value;
    }
  }

  public const int YFieldNumber = 2;
  private float y_;
  public float Y {
    get { return y_; }
    set {
      y_ = value;
    }
  }

  public const int ZFieldNumber = 3;
  private float z_;
  public float Z {
    get { return z_; }
    set {
      z_ = value;
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CMsgQAngle);
  }

  public bool Equals(CMsgQAngle other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (X != other.X) return false;
    if (Y != other.Y) return false;
    if (Z != other.Z) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (X != 0F) hash ^= X.GetHashCode();
    if (Y != 0F) hash ^= Y.GetHashCode();
    if (Z != 0F) hash ^= Z.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (X != 0F) {
      output.WriteRawTag(13);
      output.WriteFloat(X);
    }
    if (Y != 0F) {
      output.WriteRawTag(21);
      output.WriteFloat(Y);
    }
    if (Z != 0F) {
      output.WriteRawTag(29);
      output.WriteFloat(Z);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (X != 0F) {
      size += 1 + 4;
    }
    if (Y != 0F) {
      size += 1 + 4;
    }
    if (Z != 0F) {
      size += 1 + 4;
    }
    return size;
  }

  public void MergeFrom(CMsgQAngle other) {
    if (other == null) {
      return;
    }
    if (other.X != 0F) {
      X = other.X;
    }
    if (other.Y != 0F) {
      Y = other.Y;
    }
    if (other.Z != 0F) {
      Z = other.Z;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 13: {
          X = input.ReadFloat();
          break;
        }
        case 21: {
          Y = input.ReadFloat();
          break;
        }
        case 29: {
          Z = input.ReadFloat();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CMsgRGBA : pb::IMessage<CMsgRGBA> {
  private static readonly pb::MessageParser<CMsgRGBA> _parser = new pb::MessageParser<CMsgRGBA>(() => new CMsgRGBA());
  public static pb::MessageParser<CMsgRGBA> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[3]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CMsgRGBA() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CMsgRGBA(CMsgRGBA other) : this() {
    r_ = other.r_;
    g_ = other.g_;
    b_ = other.b_;
    a_ = other.a_;
  }

  public CMsgRGBA Clone() {
    return new CMsgRGBA(this);
  }

  public const int RFieldNumber = 1;
  private int r_;
  public int R {
    get { return r_; }
    set {
      r_ = value;
    }
  }

  public const int GFieldNumber = 2;
  private int g_;
  public int G {
    get { return g_; }
    set {
      g_ = value;
    }
  }

  public const int BFieldNumber = 3;
  private int b_;
  public int B {
    get { return b_; }
    set {
      b_ = value;
    }
  }

  public const int AFieldNumber = 4;
  private int a_;
  public int A {
    get { return a_; }
    set {
      a_ = value;
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CMsgRGBA);
  }

  public bool Equals(CMsgRGBA other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (R != other.R) return false;
    if (G != other.G) return false;
    if (B != other.B) return false;
    if (A != other.A) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (R != 0) hash ^= R.GetHashCode();
    if (G != 0) hash ^= G.GetHashCode();
    if (B != 0) hash ^= B.GetHashCode();
    if (A != 0) hash ^= A.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (R != 0) {
      output.WriteRawTag(8);
      output.WriteInt32(R);
    }
    if (G != 0) {
      output.WriteRawTag(16);
      output.WriteInt32(G);
    }
    if (B != 0) {
      output.WriteRawTag(24);
      output.WriteInt32(B);
    }
    if (A != 0) {
      output.WriteRawTag(32);
      output.WriteInt32(A);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (R != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(R);
    }
    if (G != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(G);
    }
    if (B != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(B);
    }
    if (A != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(A);
    }
    return size;
  }

  public void MergeFrom(CMsgRGBA other) {
    if (other == null) {
      return;
    }
    if (other.R != 0) {
      R = other.R;
    }
    if (other.G != 0) {
      G = other.G;
    }
    if (other.B != 0) {
      B = other.B;
    }
    if (other.A != 0) {
      A = other.A;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          R = input.ReadInt32();
          break;
        }
        case 16: {
          G = input.ReadInt32();
          break;
        }
        case 24: {
          B = input.ReadInt32();
          break;
        }
        case 32: {
          A = input.ReadInt32();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CNETMsg_Tick : pb::IMessage<CNETMsg_Tick> {
  private static readonly pb::MessageParser<CNETMsg_Tick> _parser = new pb::MessageParser<CNETMsg_Tick>(() => new CNETMsg_Tick());
  public static pb::MessageParser<CNETMsg_Tick> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[4]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CNETMsg_Tick() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CNETMsg_Tick(CNETMsg_Tick other) : this() {
    tick_ = other.tick_;
    hostComputationtime_ = other.hostComputationtime_;
    hostComputationtimeStdDeviation_ = other.hostComputationtimeStdDeviation_;
    hostFramestarttimeStdDeviation_ = other.hostFramestarttimeStdDeviation_;
  }

  public CNETMsg_Tick Clone() {
    return new CNETMsg_Tick(this);
  }

  public const int TickFieldNumber = 1;
  private uint tick_;
  public uint Tick {
    get { return tick_; }
    set {
      tick_ = value;
    }
  }

  public const int HostComputationtimeFieldNumber = 4;
  private uint hostComputationtime_;
  public uint HostComputationtime {
    get { return hostComputationtime_; }
    set {
      hostComputationtime_ = value;
    }
  }

  public const int HostComputationtimeStdDeviationFieldNumber = 5;
  private uint hostComputationtimeStdDeviation_;
  public uint HostComputationtimeStdDeviation {
    get { return hostComputationtimeStdDeviation_; }
    set {
      hostComputationtimeStdDeviation_ = value;
    }
  }

  public const int HostFramestarttimeStdDeviationFieldNumber = 6;
  private uint hostFramestarttimeStdDeviation_;
  public uint HostFramestarttimeStdDeviation {
    get { return hostFramestarttimeStdDeviation_; }
    set {
      hostFramestarttimeStdDeviation_ = value;
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CNETMsg_Tick);
  }

  public bool Equals(CNETMsg_Tick other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (Tick != other.Tick) return false;
    if (HostComputationtime != other.HostComputationtime) return false;
    if (HostComputationtimeStdDeviation != other.HostComputationtimeStdDeviation) return false;
    if (HostFramestarttimeStdDeviation != other.HostFramestarttimeStdDeviation) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (Tick != 0) hash ^= Tick.GetHashCode();
    if (HostComputationtime != 0) hash ^= HostComputationtime.GetHashCode();
    if (HostComputationtimeStdDeviation != 0) hash ^= HostComputationtimeStdDeviation.GetHashCode();
    if (HostFramestarttimeStdDeviation != 0) hash ^= HostFramestarttimeStdDeviation.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (Tick != 0) {
      output.WriteRawTag(8);
      output.WriteUInt32(Tick);
    }
    if (HostComputationtime != 0) {
      output.WriteRawTag(32);
      output.WriteUInt32(HostComputationtime);
    }
    if (HostComputationtimeStdDeviation != 0) {
      output.WriteRawTag(40);
      output.WriteUInt32(HostComputationtimeStdDeviation);
    }
    if (HostFramestarttimeStdDeviation != 0) {
      output.WriteRawTag(48);
      output.WriteUInt32(HostFramestarttimeStdDeviation);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (Tick != 0) {
      size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Tick);
    }
    if (HostComputationtime != 0) {
      size += 1 + pb::CodedOutputStream.ComputeUInt32Size(HostComputationtime);
    }
    if (HostComputationtimeStdDeviation != 0) {
      size += 1 + pb::CodedOutputStream.ComputeUInt32Size(HostComputationtimeStdDeviation);
    }
    if (HostFramestarttimeStdDeviation != 0) {
      size += 1 + pb::CodedOutputStream.ComputeUInt32Size(HostFramestarttimeStdDeviation);
    }
    return size;
  }

  public void MergeFrom(CNETMsg_Tick other) {
    if (other == null) {
      return;
    }
    if (other.Tick != 0) {
      Tick = other.Tick;
    }
    if (other.HostComputationtime != 0) {
      HostComputationtime = other.HostComputationtime;
    }
    if (other.HostComputationtimeStdDeviation != 0) {
      HostComputationtimeStdDeviation = other.HostComputationtimeStdDeviation;
    }
    if (other.HostFramestarttimeStdDeviation != 0) {
      HostFramestarttimeStdDeviation = other.HostFramestarttimeStdDeviation;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          Tick = input.ReadUInt32();
          break;
        }
        case 32: {
          HostComputationtime = input.ReadUInt32();
          break;
        }
        case 40: {
          HostComputationtimeStdDeviation = input.ReadUInt32();
          break;
        }
        case 48: {
          HostFramestarttimeStdDeviation = input.ReadUInt32();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CNETMsg_StringCmd : pb::IMessage<CNETMsg_StringCmd> {
  private static readonly pb::MessageParser<CNETMsg_StringCmd> _parser = new pb::MessageParser<CNETMsg_StringCmd>(() => new CNETMsg_StringCmd());
  public static pb::MessageParser<CNETMsg_StringCmd> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[5]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CNETMsg_StringCmd() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CNETMsg_StringCmd(CNETMsg_StringCmd other) : this() {
    command_ = other.command_;
  }

  public CNETMsg_StringCmd Clone() {
    return new CNETMsg_StringCmd(this);
  }

  public const int CommandFieldNumber = 1;
  private string command_ = "";
  public string Command {
    get { return command_; }
    set {
      command_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CNETMsg_StringCmd);
  }

  public bool Equals(CNETMsg_StringCmd other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (Command != other.Command) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (Command.Length != 0) hash ^= Command.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (Command.Length != 0) {
      output.WriteRawTag(10);
      output.WriteString(Command);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (Command.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Command);
    }
    return size;
  }

  public void MergeFrom(CNETMsg_StringCmd other) {
    if (other == null) {
      return;
    }
    if (other.Command.Length != 0) {
      Command = other.Command;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 10: {
          Command = input.ReadString();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CNETMsg_SignonState : pb::IMessage<CNETMsg_SignonState> {
  private static readonly pb::MessageParser<CNETMsg_SignonState> _parser = new pb::MessageParser<CNETMsg_SignonState>(() => new CNETMsg_SignonState());
  public static pb::MessageParser<CNETMsg_SignonState> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[6]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CNETMsg_SignonState() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CNETMsg_SignonState(CNETMsg_SignonState other) : this() {
    signonState_ = other.signonState_;
    spawnCount_ = other.spawnCount_;
    numServerPlayers_ = other.numServerPlayers_;
    playersNetworkids_ = other.playersNetworkids_.Clone();
    mapName_ = other.mapName_;
  }

  public CNETMsg_SignonState Clone() {
    return new CNETMsg_SignonState(this);
  }

  public const int SignonStateFieldNumber = 1;
  private uint signonState_;
  public uint SignonState {
    get { return signonState_; }
    set {
      signonState_ = value;
    }
  }

  public const int SpawnCountFieldNumber = 2;
  private uint spawnCount_;
  public uint SpawnCount {
    get { return spawnCount_; }
    set {
      spawnCount_ = value;
    }
  }

  public const int NumServerPlayersFieldNumber = 3;
  private uint numServerPlayers_;
  public uint NumServerPlayers {
    get { return numServerPlayers_; }
    set {
      numServerPlayers_ = value;
    }
  }

  public const int PlayersNetworkidsFieldNumber = 4;
  private static readonly pb::FieldCodec<string> _repeated_playersNetworkids_codec
      = pb::FieldCodec.ForString(34);
  private readonly pbc::RepeatedField<string> playersNetworkids_ = new pbc::RepeatedField<string>();
  public pbc::RepeatedField<string> PlayersNetworkids {
    get { return playersNetworkids_; }
  }

  public const int MapNameFieldNumber = 5;
  private string mapName_ = "";
  public string MapName {
    get { return mapName_; }
    set {
      mapName_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CNETMsg_SignonState);
  }

  public bool Equals(CNETMsg_SignonState other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (SignonState != other.SignonState) return false;
    if (SpawnCount != other.SpawnCount) return false;
    if (NumServerPlayers != other.NumServerPlayers) return false;
    if(!playersNetworkids_.Equals(other.playersNetworkids_)) return false;
    if (MapName != other.MapName) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (SignonState != 0) hash ^= SignonState.GetHashCode();
    if (SpawnCount != 0) hash ^= SpawnCount.GetHashCode();
    if (NumServerPlayers != 0) hash ^= NumServerPlayers.GetHashCode();
    hash ^= playersNetworkids_.GetHashCode();
    if (MapName.Length != 0) hash ^= MapName.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (SignonState != 0) {
      output.WriteRawTag(8);
      output.WriteUInt32(SignonState);
    }
    if (SpawnCount != 0) {
      output.WriteRawTag(16);
      output.WriteUInt32(SpawnCount);
    }
    if (NumServerPlayers != 0) {
      output.WriteRawTag(24);
      output.WriteUInt32(NumServerPlayers);
    }
    playersNetworkids_.WriteTo(output, _repeated_playersNetworkids_codec);
    if (MapName.Length != 0) {
      output.WriteRawTag(42);
      output.WriteString(MapName);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (SignonState != 0) {
      size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SignonState);
    }
    if (SpawnCount != 0) {
      size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SpawnCount);
    }
    if (NumServerPlayers != 0) {
      size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NumServerPlayers);
    }
    size += playersNetworkids_.CalculateSize(_repeated_playersNetworkids_codec);
    if (MapName.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(MapName);
    }
    return size;
  }

  public void MergeFrom(CNETMsg_SignonState other) {
    if (other == null) {
      return;
    }
    if (other.SignonState != 0) {
      SignonState = other.SignonState;
    }
    if (other.SpawnCount != 0) {
      SpawnCount = other.SpawnCount;
    }
    if (other.NumServerPlayers != 0) {
      NumServerPlayers = other.NumServerPlayers;
    }
    playersNetworkids_.Add(other.playersNetworkids_);
    if (other.MapName.Length != 0) {
      MapName = other.MapName;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          SignonState = input.ReadUInt32();
          break;
        }
        case 16: {
          SpawnCount = input.ReadUInt32();
          break;
        }
        case 24: {
          NumServerPlayers = input.ReadUInt32();
          break;
        }
        case 34: {
          playersNetworkids_.AddEntriesFrom(input, _repeated_playersNetworkids_codec);
          break;
        }
        case 42: {
          MapName = input.ReadString();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CMsg_CVars : pb::IMessage<CMsg_CVars> {
  private static readonly pb::MessageParser<CMsg_CVars> _parser = new pb::MessageParser<CMsg_CVars>(() => new CMsg_CVars());
  public static pb::MessageParser<CMsg_CVars> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[7]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CMsg_CVars() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CMsg_CVars(CMsg_CVars other) : this() {
    cvars_ = other.cvars_.Clone();
  }

  public CMsg_CVars Clone() {
    return new CMsg_CVars(this);
  }

  public const int CvarsFieldNumber = 1;
  private static readonly pb::FieldCodec<global::CMsg_CVars.Types.CVar> _repeated_cvars_codec
      = pb::FieldCodec.ForMessage(10, global::CMsg_CVars.Types.CVar.Parser);
  private readonly pbc::RepeatedField<global::CMsg_CVars.Types.CVar> cvars_ = new pbc::RepeatedField<global::CMsg_CVars.Types.CVar>();
  public pbc::RepeatedField<global::CMsg_CVars.Types.CVar> Cvars {
    get { return cvars_; }
  }

  public override bool Equals(object other) {
    return Equals(other as CMsg_CVars);
  }

  public bool Equals(CMsg_CVars other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if(!cvars_.Equals(other.cvars_)) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    hash ^= cvars_.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    cvars_.WriteTo(output, _repeated_cvars_codec);
  }

  public int CalculateSize() {
    int size = 0;
    size += cvars_.CalculateSize(_repeated_cvars_codec);
    return size;
  }

  public void MergeFrom(CMsg_CVars other) {
    if (other == null) {
      return;
    }
    cvars_.Add(other.cvars_);
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 10: {
          cvars_.AddEntriesFrom(input, _repeated_cvars_codec);
          break;
        }
      }
    }
  }

  #region Nested types
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Types {
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class CVar : pb::IMessage<CVar> {
      private static readonly pb::MessageParser<CVar> _parser = new pb::MessageParser<CVar>(() => new CVar());
      public static pb::MessageParser<CVar> Parser { get { return _parser; } }

      public static pbr::MessageDescriptor Descriptor {
        get { return global::CMsg_CVars.Descriptor.NestedTypes[0]; }
      }

      pbr::MessageDescriptor pb::IMessage.Descriptor {
        get { return Descriptor; }
      }

      public CVar() {
        OnConstruction();
      }

      partial void OnConstruction();

      public CVar(CVar other) : this() {
        name_ = other.name_;
        value_ = other.value_;
      }

      public CVar Clone() {
        return new CVar(this);
      }

      public const int NameFieldNumber = 1;
      private string name_ = "";
      public string Name {
        get { return name_; }
        set {
          name_ = pb::Preconditions.CheckNotNull(value, "value");
        }
      }

      public const int ValueFieldNumber = 2;
      private string value_ = "";
      public string Value {
        get { return value_; }
        set {
          value_ = pb::Preconditions.CheckNotNull(value, "value");
        }
      }

      public override bool Equals(object other) {
        return Equals(other as CVar);
      }

      public bool Equals(CVar other) {
        if (ReferenceEquals(other, null)) {
          return false;
        }
        if (ReferenceEquals(other, this)) {
          return true;
        }
        if (Name != other.Name) return false;
        if (Value != other.Value) return false;
        return true;
      }

      public override int GetHashCode() {
        int hash = 1;
        if (Name.Length != 0) hash ^= Name.GetHashCode();
        if (Value.Length != 0) hash ^= Value.GetHashCode();
        return hash;
      }

      public override string ToString() {
        return pb::JsonFormatter.Default.Format(this);
      }

      public void WriteTo(pb::CodedOutputStream output) {
        if (Name.Length != 0) {
          output.WriteRawTag(10);
          output.WriteString(Name);
        }
        if (Value.Length != 0) {
          output.WriteRawTag(18);
          output.WriteString(Value);
        }
      }

      public int CalculateSize() {
        int size = 0;
        if (Name.Length != 0) {
          size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
        }
        if (Value.Length != 0) {
          size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
        }
        return size;
      }

      public void MergeFrom(CVar other) {
        if (other == null) {
          return;
        }
        if (other.Name.Length != 0) {
          Name = other.Name;
        }
        if (other.Value.Length != 0) {
          Value = other.Value;
        }
      }

      public void MergeFrom(pb::CodedInputStream input) {
        uint tag;
        while ((tag = input.ReadTag()) != 0) {
          switch(tag) {
            default:
              input.SkipLastField();
              break;
            case 10: {
              Name = input.ReadString();
              break;
            }
            case 18: {
              Value = input.ReadString();
              break;
            }
          }
        }
      }

    }

  }
  #endregion

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CNETMsg_SetConVar : pb::IMessage<CNETMsg_SetConVar> {
  private static readonly pb::MessageParser<CNETMsg_SetConVar> _parser = new pb::MessageParser<CNETMsg_SetConVar>(() => new CNETMsg_SetConVar());
  public static pb::MessageParser<CNETMsg_SetConVar> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[8]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CNETMsg_SetConVar() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CNETMsg_SetConVar(CNETMsg_SetConVar other) : this() {
    Convars = other.convars_ != null ? other.Convars.Clone() : null;
  }

  public CNETMsg_SetConVar Clone() {
    return new CNETMsg_SetConVar(this);
  }

  public const int ConvarsFieldNumber = 1;
  private global::CMsg_CVars convars_;
  public global::CMsg_CVars Convars {
    get { return convars_; }
    set {
      convars_ = value;
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CNETMsg_SetConVar);
  }

  public bool Equals(CNETMsg_SetConVar other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (!object.Equals(Convars, other.Convars)) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (convars_ != null) hash ^= Convars.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (convars_ != null) {
      output.WriteRawTag(10);
      output.WriteMessage(Convars);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (convars_ != null) {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Convars);
    }
    return size;
  }

  public void MergeFrom(CNETMsg_SetConVar other) {
    if (other == null) {
      return;
    }
    if (other.convars_ != null) {
      if (convars_ == null) {
        convars_ = new global::CMsg_CVars();
      }
      Convars.MergeFrom(other.Convars);
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 10: {
          if (convars_ == null) {
            convars_ = new global::CMsg_CVars();
          }
          input.ReadMessage(convars_);
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CNETMsg_NOP : pb::IMessage<CNETMsg_NOP> {
  private static readonly pb::MessageParser<CNETMsg_NOP> _parser = new pb::MessageParser<CNETMsg_NOP>(() => new CNETMsg_NOP());
  public static pb::MessageParser<CNETMsg_NOP> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[9]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CNETMsg_NOP() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CNETMsg_NOP(CNETMsg_NOP other) : this() {
  }

  public CNETMsg_NOP Clone() {
    return new CNETMsg_NOP(this);
  }

  public override bool Equals(object other) {
    return Equals(other as CNETMsg_NOP);
  }

  public bool Equals(CNETMsg_NOP other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
  }

  public int CalculateSize() {
    int size = 0;
    return size;
  }

  public void MergeFrom(CNETMsg_NOP other) {
    if (other == null) {
      return;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CNETMsg_Disconnect : pb::IMessage<CNETMsg_Disconnect> {
  private static readonly pb::MessageParser<CNETMsg_Disconnect> _parser = new pb::MessageParser<CNETMsg_Disconnect>(() => new CNETMsg_Disconnect());
  public static pb::MessageParser<CNETMsg_Disconnect> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[10]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CNETMsg_Disconnect() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CNETMsg_Disconnect(CNETMsg_Disconnect other) : this() {
    text_ = other.text_;
  }

  public CNETMsg_Disconnect Clone() {
    return new CNETMsg_Disconnect(this);
  }

  public const int TextFieldNumber = 1;
  private string text_ = "";
  public string Text {
    get { return text_; }
    set {
      text_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CNETMsg_Disconnect);
  }

  public bool Equals(CNETMsg_Disconnect other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (Text != other.Text) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (Text.Length != 0) hash ^= Text.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (Text.Length != 0) {
      output.WriteRawTag(10);
      output.WriteString(Text);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (Text.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Text);
    }
    return size;
  }

  public void MergeFrom(CNETMsg_Disconnect other) {
    if (other == null) {
      return;
    }
    if (other.Text.Length != 0) {
      Text = other.Text;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 10: {
          Text = input.ReadString();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CNETMsg_File : pb::IMessage<CNETMsg_File> {
  private static readonly pb::MessageParser<CNETMsg_File> _parser = new pb::MessageParser<CNETMsg_File>(() => new CNETMsg_File());
  public static pb::MessageParser<CNETMsg_File> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[11]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CNETMsg_File() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CNETMsg_File(CNETMsg_File other) : this() {
    transferId_ = other.transferId_;
    fileName_ = other.fileName_;
    isReplayDemoFile_ = other.isReplayDemoFile_;
    deny_ = other.deny_;
  }

  public CNETMsg_File Clone() {
    return new CNETMsg_File(this);
  }

  public const int TransferIdFieldNumber = 1;
  private int transferId_;
  public int TransferId {
    get { return transferId_; }
    set {
      transferId_ = value;
    }
  }

  public const int FileNameFieldNumber = 2;
  private string fileName_ = "";
  public string FileName {
    get { return fileName_; }
    set {
      fileName_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public const int IsReplayDemoFileFieldNumber = 3;
  private bool isReplayDemoFile_;
  public bool IsReplayDemoFile {
    get { return isReplayDemoFile_; }
    set {
      isReplayDemoFile_ = value;
    }
  }

  public const int DenyFieldNumber = 4;
  private bool deny_;
  public bool Deny {
    get { return deny_; }
    set {
      deny_ = value;
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CNETMsg_File);
  }

  public bool Equals(CNETMsg_File other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (TransferId != other.TransferId) return false;
    if (FileName != other.FileName) return false;
    if (IsReplayDemoFile != other.IsReplayDemoFile) return false;
    if (Deny != other.Deny) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (TransferId != 0) hash ^= TransferId.GetHashCode();
    if (FileName.Length != 0) hash ^= FileName.GetHashCode();
    if (IsReplayDemoFile != false) hash ^= IsReplayDemoFile.GetHashCode();
    if (Deny != false) hash ^= Deny.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (TransferId != 0) {
      output.WriteRawTag(8);
      output.WriteInt32(TransferId);
    }
    if (FileName.Length != 0) {
      output.WriteRawTag(18);
      output.WriteString(FileName);
    }
    if (IsReplayDemoFile != false) {
      output.WriteRawTag(24);
      output.WriteBool(IsReplayDemoFile);
    }
    if (Deny != false) {
      output.WriteRawTag(32);
      output.WriteBool(Deny);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (TransferId != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(TransferId);
    }
    if (FileName.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(FileName);
    }
    if (IsReplayDemoFile != false) {
      size += 1 + 1;
    }
    if (Deny != false) {
      size += 1 + 1;
    }
    return size;
  }

  public void MergeFrom(CNETMsg_File other) {
    if (other == null) {
      return;
    }
    if (other.TransferId != 0) {
      TransferId = other.TransferId;
    }
    if (other.FileName.Length != 0) {
      FileName = other.FileName;
    }
    if (other.IsReplayDemoFile != false) {
      IsReplayDemoFile = other.IsReplayDemoFile;
    }
    if (other.Deny != false) {
      Deny = other.Deny;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          TransferId = input.ReadInt32();
          break;
        }
        case 18: {
          FileName = input.ReadString();
          break;
        }
        case 24: {
          IsReplayDemoFile = input.ReadBool();
          break;
        }
        case 32: {
          Deny = input.ReadBool();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_ServerInfo : pb::IMessage<CSVCMsg_ServerInfo> {
  private static readonly pb::MessageParser<CSVCMsg_ServerInfo> _parser = new pb::MessageParser<CSVCMsg_ServerInfo>(() => new CSVCMsg_ServerInfo());
  public static pb::MessageParser<CSVCMsg_ServerInfo> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[12]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_ServerInfo() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_ServerInfo(CSVCMsg_ServerInfo other) : this() {
    protocol_ = other.protocol_;
    serverCount_ = other.serverCount_;
    isDedicated_ = other.isDedicated_;
    isOfficialValveServer_ = other.isOfficialValveServer_;
    isHltv_ = other.isHltv_;
    isReplay_ = other.isReplay_;
    isRedirectingToProxyRelay_ = other.isRedirectingToProxyRelay_;
    cOs_ = other.cOs_;
    mapCrc_ = other.mapCrc_;
    clientCrc_ = other.clientCrc_;
    stringTableCrc_ = other.stringTableCrc_;
    maxClients_ = other.maxClients_;
    maxClasses_ = other.maxClasses_;
    playerSlot_ = other.playerSlot_;
    tickInterval_ = other.tickInterval_;
    gameDir_ = other.gameDir_;
    mapName_ = other.mapName_;
    mapGroupName_ = other.mapGroupName_;
    skyName_ = other.skyName_;
    hostName_ = other.hostName_;
    ugcMapId_ = other.ugcMapId_;
  }

  public CSVCMsg_ServerInfo Clone() {
    return new CSVCMsg_ServerInfo(this);
  }

  public const int ProtocolFieldNumber = 1;
  private int protocol_;
  public int Protocol {
    get { return protocol_; }
    set {
      protocol_ = value;
    }
  }

  public const int ServerCountFieldNumber = 2;
  private int serverCount_;
  public int ServerCount {
    get { return serverCount_; }
    set {
      serverCount_ = value;
    }
  }

  public const int IsDedicatedFieldNumber = 3;
  private bool isDedicated_;
  public bool IsDedicated {
    get { return isDedicated_; }
    set {
      isDedicated_ = value;
    }
  }

  public const int IsOfficialValveServerFieldNumber = 4;
  private bool isOfficialValveServer_;
  public bool IsOfficialValveServer {
    get { return isOfficialValveServer_; }
    set {
      isOfficialValveServer_ = value;
    }
  }

  public const int IsHltvFieldNumber = 5;
  private bool isHltv_;
  public bool IsHltv {
    get { return isHltv_; }
    set {
      isHltv_ = value;
    }
  }

  public const int IsReplayFieldNumber = 6;
  private bool isReplay_;
  public bool IsReplay {
    get { return isReplay_; }
    set {
      isReplay_ = value;
    }
  }

  public const int IsRedirectingToProxyRelayFieldNumber = 21;
  private bool isRedirectingToProxyRelay_;
  public bool IsRedirectingToProxyRelay {
    get { return isRedirectingToProxyRelay_; }
    set {
      isRedirectingToProxyRelay_ = value;
    }
  }

  public const int COsFieldNumber = 7;
  private int cOs_;
  public int COs {
    get { return cOs_; }
    set {
      cOs_ = value;
    }
  }

  public const int MapCrcFieldNumber = 8;
  private uint mapCrc_;
  public uint MapCrc {
    get { return mapCrc_; }
    set {
      mapCrc_ = value;
    }
  }

  public const int ClientCrcFieldNumber = 9;
  private uint clientCrc_;
  public uint ClientCrc {
    get { return clientCrc_; }
    set {
      clientCrc_ = value;
    }
  }

  public const int StringTableCrcFieldNumber = 10;
  private uint stringTableCrc_;
  public uint StringTableCrc {
    get { return stringTableCrc_; }
    set {
      stringTableCrc_ = value;
    }
  }

  public const int MaxClientsFieldNumber = 11;
  private int maxClients_;
  public int MaxClients {
    get { return maxClients_; }
    set {
      maxClients_ = value;
    }
  }

  public const int MaxClassesFieldNumber = 12;
  private int maxClasses_;
  public int MaxClasses {
    get { return maxClasses_; }
    set {
      maxClasses_ = value;
    }
  }

  public const int PlayerSlotFieldNumber = 13;
  private int playerSlot_;
  public int PlayerSlot {
    get { return playerSlot_; }
    set {
      playerSlot_ = value;
    }
  }

  public const int TickIntervalFieldNumber = 14;
  private float tickInterval_;
  public float TickInterval {
    get { return tickInterval_; }
    set {
      tickInterval_ = value;
    }
  }

  public const int GameDirFieldNumber = 15;
  private string gameDir_ = "";
  public string GameDir {
    get { return gameDir_; }
    set {
      gameDir_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public const int MapNameFieldNumber = 16;
  private string mapName_ = "";
  public string MapName {
    get { return mapName_; }
    set {
      mapName_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public const int MapGroupNameFieldNumber = 17;
  private string mapGroupName_ = "";
  public string MapGroupName {
    get { return mapGroupName_; }
    set {
      mapGroupName_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public const int SkyNameFieldNumber = 18;
  private string skyName_ = "";
  public string SkyName {
    get { return skyName_; }
    set {
      skyName_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public const int HostNameFieldNumber = 19;
  private string hostName_ = "";
  public string HostName {
    get { return hostName_; }
    set {
      hostName_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public const int UgcMapIdFieldNumber = 22;
  private ulong ugcMapId_;
  public ulong UgcMapId {
    get { return ugcMapId_; }
    set {
      ugcMapId_ = value;
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_ServerInfo);
  }

  public bool Equals(CSVCMsg_ServerInfo other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (Protocol != other.Protocol) return false;
    if (ServerCount != other.ServerCount) return false;
    if (IsDedicated != other.IsDedicated) return false;
    if (IsOfficialValveServer != other.IsOfficialValveServer) return false;
    if (IsHltv != other.IsHltv) return false;
    if (IsReplay != other.IsReplay) return false;
    if (IsRedirectingToProxyRelay != other.IsRedirectingToProxyRelay) return false;
    if (COs != other.COs) return false;
    if (MapCrc != other.MapCrc) return false;
    if (ClientCrc != other.ClientCrc) return false;
    if (StringTableCrc != other.StringTableCrc) return false;
    if (MaxClients != other.MaxClients) return false;
    if (MaxClasses != other.MaxClasses) return false;
    if (PlayerSlot != other.PlayerSlot) return false;
    if (TickInterval != other.TickInterval) return false;
    if (GameDir != other.GameDir) return false;
    if (MapName != other.MapName) return false;
    if (MapGroupName != other.MapGroupName) return false;
    if (SkyName != other.SkyName) return false;
    if (HostName != other.HostName) return false;
    if (UgcMapId != other.UgcMapId) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (Protocol != 0) hash ^= Protocol.GetHashCode();
    if (ServerCount != 0) hash ^= ServerCount.GetHashCode();
    if (IsDedicated != false) hash ^= IsDedicated.GetHashCode();
    if (IsOfficialValveServer != false) hash ^= IsOfficialValveServer.GetHashCode();
    if (IsHltv != false) hash ^= IsHltv.GetHashCode();
    if (IsReplay != false) hash ^= IsReplay.GetHashCode();
    if (IsRedirectingToProxyRelay != false) hash ^= IsRedirectingToProxyRelay.GetHashCode();
    if (COs != 0) hash ^= COs.GetHashCode();
    if (MapCrc != 0) hash ^= MapCrc.GetHashCode();
    if (ClientCrc != 0) hash ^= ClientCrc.GetHashCode();
    if (StringTableCrc != 0) hash ^= StringTableCrc.GetHashCode();
    if (MaxClients != 0) hash ^= MaxClients.GetHashCode();
    if (MaxClasses != 0) hash ^= MaxClasses.GetHashCode();
    if (PlayerSlot != 0) hash ^= PlayerSlot.GetHashCode();
    if (TickInterval != 0F) hash ^= TickInterval.GetHashCode();
    if (GameDir.Length != 0) hash ^= GameDir.GetHashCode();
    if (MapName.Length != 0) hash ^= MapName.GetHashCode();
    if (MapGroupName.Length != 0) hash ^= MapGroupName.GetHashCode();
    if (SkyName.Length != 0) hash ^= SkyName.GetHashCode();
    if (HostName.Length != 0) hash ^= HostName.GetHashCode();
    if (UgcMapId != 0UL) hash ^= UgcMapId.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (Protocol != 0) {
      output.WriteRawTag(8);
      output.WriteInt32(Protocol);
    }
    if (ServerCount != 0) {
      output.WriteRawTag(16);
      output.WriteInt32(ServerCount);
    }
    if (IsDedicated != false) {
      output.WriteRawTag(24);
      output.WriteBool(IsDedicated);
    }
    if (IsOfficialValveServer != false) {
      output.WriteRawTag(32);
      output.WriteBool(IsOfficialValveServer);
    }
    if (IsHltv != false) {
      output.WriteRawTag(40);
      output.WriteBool(IsHltv);
    }
    if (IsReplay != false) {
      output.WriteRawTag(48);
      output.WriteBool(IsReplay);
    }
    if (COs != 0) {
      output.WriteRawTag(56);
      output.WriteInt32(COs);
    }
    if (MapCrc != 0) {
      output.WriteRawTag(69);
      output.WriteFixed32(MapCrc);
    }
    if (ClientCrc != 0) {
      output.WriteRawTag(77);
      output.WriteFixed32(ClientCrc);
    }
    if (StringTableCrc != 0) {
      output.WriteRawTag(85);
      output.WriteFixed32(StringTableCrc);
    }
    if (MaxClients != 0) {
      output.WriteRawTag(88);
      output.WriteInt32(MaxClients);
    }
    if (MaxClasses != 0) {
      output.WriteRawTag(96);
      output.WriteInt32(MaxClasses);
    }
    if (PlayerSlot != 0) {
      output.WriteRawTag(104);
      output.WriteInt32(PlayerSlot);
    }
    if (TickInterval != 0F) {
      output.WriteRawTag(117);
      output.WriteFloat(TickInterval);
    }
    if (GameDir.Length != 0) {
      output.WriteRawTag(122);
      output.WriteString(GameDir);
    }
    if (MapName.Length != 0) {
      output.WriteRawTag(130, 1);
      output.WriteString(MapName);
    }
    if (MapGroupName.Length != 0) {
      output.WriteRawTag(138, 1);
      output.WriteString(MapGroupName);
    }
    if (SkyName.Length != 0) {
      output.WriteRawTag(146, 1);
      output.WriteString(SkyName);
    }
    if (HostName.Length != 0) {
      output.WriteRawTag(154, 1);
      output.WriteString(HostName);
    }
    if (IsRedirectingToProxyRelay != false) {
      output.WriteRawTag(168, 1);
      output.WriteBool(IsRedirectingToProxyRelay);
    }
    if (UgcMapId != 0UL) {
      output.WriteRawTag(176, 1);
      output.WriteUInt64(UgcMapId);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (Protocol != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(Protocol);
    }
    if (ServerCount != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(ServerCount);
    }
    if (IsDedicated != false) {
      size += 1 + 1;
    }
    if (IsOfficialValveServer != false) {
      size += 1 + 1;
    }
    if (IsHltv != false) {
      size += 1 + 1;
    }
    if (IsReplay != false) {
      size += 1 + 1;
    }
    if (IsRedirectingToProxyRelay != false) {
      size += 2 + 1;
    }
    if (COs != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(COs);
    }
    if (MapCrc != 0) {
      size += 1 + 4;
    }
    if (ClientCrc != 0) {
      size += 1 + 4;
    }
    if (StringTableCrc != 0) {
      size += 1 + 4;
    }
    if (MaxClients != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxClients);
    }
    if (MaxClasses != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxClasses);
    }
    if (PlayerSlot != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(PlayerSlot);
    }
    if (TickInterval != 0F) {
      size += 1 + 4;
    }
    if (GameDir.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(GameDir);
    }
    if (MapName.Length != 0) {
      size += 2 + pb::CodedOutputStream.ComputeStringSize(MapName);
    }
    if (MapGroupName.Length != 0) {
      size += 2 + pb::CodedOutputStream.ComputeStringSize(MapGroupName);
    }
    if (SkyName.Length != 0) {
      size += 2 + pb::CodedOutputStream.ComputeStringSize(SkyName);
    }
    if (HostName.Length != 0) {
      size += 2 + pb::CodedOutputStream.ComputeStringSize(HostName);
    }
    if (UgcMapId != 0UL) {
      size += 2 + pb::CodedOutputStream.ComputeUInt64Size(UgcMapId);
    }
    return size;
  }

  public void MergeFrom(CSVCMsg_ServerInfo other) {
    if (other == null) {
      return;
    }
    if (other.Protocol != 0) {
      Protocol = other.Protocol;
    }
    if (other.ServerCount != 0) {
      ServerCount = other.ServerCount;
    }
    if (other.IsDedicated != false) {
      IsDedicated = other.IsDedicated;
    }
    if (other.IsOfficialValveServer != false) {
      IsOfficialValveServer = other.IsOfficialValveServer;
    }
    if (other.IsHltv != false) {
      IsHltv = other.IsHltv;
    }
    if (other.IsReplay != false) {
      IsReplay = other.IsReplay;
    }
    if (other.IsRedirectingToProxyRelay != false) {
      IsRedirectingToProxyRelay = other.IsRedirectingToProxyRelay;
    }
    if (other.COs != 0) {
      COs = other.COs;
    }
    if (other.MapCrc != 0) {
      MapCrc = other.MapCrc;
    }
    if (other.ClientCrc != 0) {
      ClientCrc = other.ClientCrc;
    }
    if (other.StringTableCrc != 0) {
      StringTableCrc = other.StringTableCrc;
    }
    if (other.MaxClients != 0) {
      MaxClients = other.MaxClients;
    }
    if (other.MaxClasses != 0) {
      MaxClasses = other.MaxClasses;
    }
    if (other.PlayerSlot != 0) {
      PlayerSlot = other.PlayerSlot;
    }
    if (other.TickInterval != 0F) {
      TickInterval = other.TickInterval;
    }
    if (other.GameDir.Length != 0) {
      GameDir = other.GameDir;
    }
    if (other.MapName.Length != 0) {
      MapName = other.MapName;
    }
    if (other.MapGroupName.Length != 0) {
      MapGroupName = other.MapGroupName;
    }
    if (other.SkyName.Length != 0) {
      SkyName = other.SkyName;
    }
    if (other.HostName.Length != 0) {
      HostName = other.HostName;
    }
    if (other.UgcMapId != 0UL) {
      UgcMapId = other.UgcMapId;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          Protocol = input.ReadInt32();
          break;
        }
        case 16: {
          ServerCount = input.ReadInt32();
          break;
        }
        case 24: {
          IsDedicated = input.ReadBool();
          break;
        }
        case 32: {
          IsOfficialValveServer = input.ReadBool();
          break;
        }
        case 40: {
          IsHltv = input.ReadBool();
          break;
        }
        case 48: {
          IsReplay = input.ReadBool();
          break;
        }
        case 56: {
          COs = input.ReadInt32();
          break;
        }
        case 69: {
          MapCrc = input.ReadFixed32();
          break;
        }
        case 77: {
          ClientCrc = input.ReadFixed32();
          break;
        }
        case 85: {
          StringTableCrc = input.ReadFixed32();
          break;
        }
        case 88: {
          MaxClients = input.ReadInt32();
          break;
        }
        case 96: {
          MaxClasses = input.ReadInt32();
          break;
        }
        case 104: {
          PlayerSlot = input.ReadInt32();
          break;
        }
        case 117: {
          TickInterval = input.ReadFloat();
          break;
        }
        case 122: {
          GameDir = input.ReadString();
          break;
        }
        case 130: {
          MapName = input.ReadString();
          break;
        }
        case 138: {
          MapGroupName = input.ReadString();
          break;
        }
        case 146: {
          SkyName = input.ReadString();
          break;
        }
        case 154: {
          HostName = input.ReadString();
          break;
        }
        case 168: {
          IsRedirectingToProxyRelay = input.ReadBool();
          break;
        }
        case 176: {
          UgcMapId = input.ReadUInt64();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_ClassInfo : pb::IMessage<CSVCMsg_ClassInfo> {
  private static readonly pb::MessageParser<CSVCMsg_ClassInfo> _parser = new pb::MessageParser<CSVCMsg_ClassInfo>(() => new CSVCMsg_ClassInfo());
  public static pb::MessageParser<CSVCMsg_ClassInfo> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[13]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_ClassInfo() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_ClassInfo(CSVCMsg_ClassInfo other) : this() {
    createOnClient_ = other.createOnClient_;
    classes_ = other.classes_.Clone();
  }

  public CSVCMsg_ClassInfo Clone() {
    return new CSVCMsg_ClassInfo(this);
  }

  public const int CreateOnClientFieldNumber = 1;
  private bool createOnClient_;
  public bool CreateOnClient {
    get { return createOnClient_; }
    set {
      createOnClient_ = value;
    }
  }

  public const int ClassesFieldNumber = 2;
  private static readonly pb::FieldCodec<global::CSVCMsg_ClassInfo.Types.class_t> _repeated_classes_codec
      = pb::FieldCodec.ForMessage(18, global::CSVCMsg_ClassInfo.Types.class_t.Parser);
  private readonly pbc::RepeatedField<global::CSVCMsg_ClassInfo.Types.class_t> classes_ = new pbc::RepeatedField<global::CSVCMsg_ClassInfo.Types.class_t>();
  public pbc::RepeatedField<global::CSVCMsg_ClassInfo.Types.class_t> Classes {
    get { return classes_; }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_ClassInfo);
  }

  public bool Equals(CSVCMsg_ClassInfo other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (CreateOnClient != other.CreateOnClient) return false;
    if(!classes_.Equals(other.classes_)) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (CreateOnClient != false) hash ^= CreateOnClient.GetHashCode();
    hash ^= classes_.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (CreateOnClient != false) {
      output.WriteRawTag(8);
      output.WriteBool(CreateOnClient);
    }
    classes_.WriteTo(output, _repeated_classes_codec);
  }

  public int CalculateSize() {
    int size = 0;
    if (CreateOnClient != false) {
      size += 1 + 1;
    }
    size += classes_.CalculateSize(_repeated_classes_codec);
    return size;
  }

  public void MergeFrom(CSVCMsg_ClassInfo other) {
    if (other == null) {
      return;
    }
    if (other.CreateOnClient != false) {
      CreateOnClient = other.CreateOnClient;
    }
    classes_.Add(other.classes_);
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          CreateOnClient = input.ReadBool();
          break;
        }
        case 18: {
          classes_.AddEntriesFrom(input, _repeated_classes_codec);
          break;
        }
      }
    }
  }

  #region Nested types
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Types {
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class class_t : pb::IMessage<class_t> {
      private static readonly pb::MessageParser<class_t> _parser = new pb::MessageParser<class_t>(() => new class_t());
      public static pb::MessageParser<class_t> Parser { get { return _parser; } }

      public static pbr::MessageDescriptor Descriptor {
        get { return global::CSVCMsg_ClassInfo.Descriptor.NestedTypes[0]; }
      }

      pbr::MessageDescriptor pb::IMessage.Descriptor {
        get { return Descriptor; }
      }

      public class_t() {
        OnConstruction();
      }

      partial void OnConstruction();

      public class_t(class_t other) : this() {
        classId_ = other.classId_;
        dataTableName_ = other.dataTableName_;
        className_ = other.className_;
      }

      public class_t Clone() {
        return new class_t(this);
      }

      public const int ClassIdFieldNumber = 1;
      private int classId_;
      public int ClassId {
        get { return classId_; }
        set {
          classId_ = value;
        }
      }

      public const int DataTableNameFieldNumber = 2;
      private string dataTableName_ = "";
      public string DataTableName {
        get { return dataTableName_; }
        set {
          dataTableName_ = pb::Preconditions.CheckNotNull(value, "value");
        }
      }

      public const int ClassNameFieldNumber = 3;
      private string className_ = "";
      public string ClassName {
        get { return className_; }
        set {
          className_ = pb::Preconditions.CheckNotNull(value, "value");
        }
      }

      public override bool Equals(object other) {
        return Equals(other as class_t);
      }

      public bool Equals(class_t other) {
        if (ReferenceEquals(other, null)) {
          return false;
        }
        if (ReferenceEquals(other, this)) {
          return true;
        }
        if (ClassId != other.ClassId) return false;
        if (DataTableName != other.DataTableName) return false;
        if (ClassName != other.ClassName) return false;
        return true;
      }

      public override int GetHashCode() {
        int hash = 1;
        if (ClassId != 0) hash ^= ClassId.GetHashCode();
        if (DataTableName.Length != 0) hash ^= DataTableName.GetHashCode();
        if (ClassName.Length != 0) hash ^= ClassName.GetHashCode();
        return hash;
      }

      public override string ToString() {
        return pb::JsonFormatter.Default.Format(this);
      }

      public void WriteTo(pb::CodedOutputStream output) {
        if (ClassId != 0) {
          output.WriteRawTag(8);
          output.WriteInt32(ClassId);
        }
        if (DataTableName.Length != 0) {
          output.WriteRawTag(18);
          output.WriteString(DataTableName);
        }
        if (ClassName.Length != 0) {
          output.WriteRawTag(26);
          output.WriteString(ClassName);
        }
      }

      public int CalculateSize() {
        int size = 0;
        if (ClassId != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(ClassId);
        }
        if (DataTableName.Length != 0) {
          size += 1 + pb::CodedOutputStream.ComputeStringSize(DataTableName);
        }
        if (ClassName.Length != 0) {
          size += 1 + pb::CodedOutputStream.ComputeStringSize(ClassName);
        }
        return size;
      }

      public void MergeFrom(class_t other) {
        if (other == null) {
          return;
        }
        if (other.ClassId != 0) {
          ClassId = other.ClassId;
        }
        if (other.DataTableName.Length != 0) {
          DataTableName = other.DataTableName;
        }
        if (other.ClassName.Length != 0) {
          ClassName = other.ClassName;
        }
      }

      public void MergeFrom(pb::CodedInputStream input) {
        uint tag;
        while ((tag = input.ReadTag()) != 0) {
          switch(tag) {
            default:
              input.SkipLastField();
              break;
            case 8: {
              ClassId = input.ReadInt32();
              break;
            }
            case 18: {
              DataTableName = input.ReadString();
              break;
            }
            case 26: {
              ClassName = input.ReadString();
              break;
            }
          }
        }
      }

    }

  }
  #endregion

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_SendTable : pb::IMessage<CSVCMsg_SendTable> {
  private static readonly pb::MessageParser<CSVCMsg_SendTable> _parser = new pb::MessageParser<CSVCMsg_SendTable>(() => new CSVCMsg_SendTable());
  public static pb::MessageParser<CSVCMsg_SendTable> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[14]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_SendTable() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_SendTable(CSVCMsg_SendTable other) : this() {
    isEnd_ = other.isEnd_;
    netTableName_ = other.netTableName_;
    needsDecoder_ = other.needsDecoder_;
    props_ = other.props_.Clone();
  }

  public CSVCMsg_SendTable Clone() {
    return new CSVCMsg_SendTable(this);
  }

  public const int IsEndFieldNumber = 1;
  private bool isEnd_;
  public bool IsEnd {
    get { return isEnd_; }
    set {
      isEnd_ = value;
    }
  }

  public const int NetTableNameFieldNumber = 2;
  private string netTableName_ = "";
  public string NetTableName {
    get { return netTableName_; }
    set {
      netTableName_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public const int NeedsDecoderFieldNumber = 3;
  private bool needsDecoder_;
  public bool NeedsDecoder {
    get { return needsDecoder_; }
    set {
      needsDecoder_ = value;
    }
  }

  public const int PropsFieldNumber = 4;
  private static readonly pb::FieldCodec<global::CSVCMsg_SendTable.Types.sendprop_t> _repeated_props_codec
      = pb::FieldCodec.ForMessage(34, global::CSVCMsg_SendTable.Types.sendprop_t.Parser);
  private readonly pbc::RepeatedField<global::CSVCMsg_SendTable.Types.sendprop_t> props_ = new pbc::RepeatedField<global::CSVCMsg_SendTable.Types.sendprop_t>();
  public pbc::RepeatedField<global::CSVCMsg_SendTable.Types.sendprop_t> Props {
    get { return props_; }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_SendTable);
  }

  public bool Equals(CSVCMsg_SendTable other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (IsEnd != other.IsEnd) return false;
    if (NetTableName != other.NetTableName) return false;
    if (NeedsDecoder != other.NeedsDecoder) return false;
    if(!props_.Equals(other.props_)) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (IsEnd != false) hash ^= IsEnd.GetHashCode();
    if (NetTableName.Length != 0) hash ^= NetTableName.GetHashCode();
    if (NeedsDecoder != false) hash ^= NeedsDecoder.GetHashCode();
    hash ^= props_.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (IsEnd != false) {
      output.WriteRawTag(8);
      output.WriteBool(IsEnd);
    }
    if (NetTableName.Length != 0) {
      output.WriteRawTag(18);
      output.WriteString(NetTableName);
    }
    if (NeedsDecoder != false) {
      output.WriteRawTag(24);
      output.WriteBool(NeedsDecoder);
    }
    props_.WriteTo(output, _repeated_props_codec);
  }

  public int CalculateSize() {
    int size = 0;
    if (IsEnd != false) {
      size += 1 + 1;
    }
    if (NetTableName.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(NetTableName);
    }
    if (NeedsDecoder != false) {
      size += 1 + 1;
    }
    size += props_.CalculateSize(_repeated_props_codec);
    return size;
  }

  public void MergeFrom(CSVCMsg_SendTable other) {
    if (other == null) {
      return;
    }
    if (other.IsEnd != false) {
      IsEnd = other.IsEnd;
    }
    if (other.NetTableName.Length != 0) {
      NetTableName = other.NetTableName;
    }
    if (other.NeedsDecoder != false) {
      NeedsDecoder = other.NeedsDecoder;
    }
    props_.Add(other.props_);
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          IsEnd = input.ReadBool();
          break;
        }
        case 18: {
          NetTableName = input.ReadString();
          break;
        }
        case 24: {
          NeedsDecoder = input.ReadBool();
          break;
        }
        case 34: {
          props_.AddEntriesFrom(input, _repeated_props_codec);
          break;
        }
      }
    }
  }

  #region Nested types
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Types {
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class sendprop_t : pb::IMessage<sendprop_t> {
      private static readonly pb::MessageParser<sendprop_t> _parser = new pb::MessageParser<sendprop_t>(() => new sendprop_t());
      public static pb::MessageParser<sendprop_t> Parser { get { return _parser; } }

      public static pbr::MessageDescriptor Descriptor {
        get { return global::CSVCMsg_SendTable.Descriptor.NestedTypes[0]; }
      }

      pbr::MessageDescriptor pb::IMessage.Descriptor {
        get { return Descriptor; }
      }

      public sendprop_t() {
        OnConstruction();
      }

      partial void OnConstruction();

      public sendprop_t(sendprop_t other) : this() {
        type_ = other.type_;
        varName_ = other.varName_;
        flags_ = other.flags_;
        priority_ = other.priority_;
        dtName_ = other.dtName_;
        numElements_ = other.numElements_;
        lowValue_ = other.lowValue_;
        highValue_ = other.highValue_;
        numBits_ = other.numBits_;
      }

      public sendprop_t Clone() {
        return new sendprop_t(this);
      }

      public const int TypeFieldNumber = 1;
      private int type_;
      public int Type {
        get { return type_; }
        set {
          type_ = value;
        }
      }

      public const int VarNameFieldNumber = 2;
      private string varName_ = "";
      public string VarName {
        get { return varName_; }
        set {
          varName_ = pb::Preconditions.CheckNotNull(value, "value");
        }
      }

      public const int FlagsFieldNumber = 3;
      private int flags_;
      public int Flags {
        get { return flags_; }
        set {
          flags_ = value;
        }
      }

      public const int PriorityFieldNumber = 4;
      private int priority_;
      public int Priority {
        get { return priority_; }
        set {
          priority_ = value;
        }
      }

      public const int DtNameFieldNumber = 5;
      private string dtName_ = "";
      public string DtName {
        get { return dtName_; }
        set {
          dtName_ = pb::Preconditions.CheckNotNull(value, "value");
        }
      }

      public const int NumElementsFieldNumber = 6;
      private int numElements_;
      public int NumElements {
        get { return numElements_; }
        set {
          numElements_ = value;
        }
      }

      public const int LowValueFieldNumber = 7;
      private float lowValue_;
      public float LowValue {
        get { return lowValue_; }
        set {
          lowValue_ = value;
        }
      }

      public const int HighValueFieldNumber = 8;
      private float highValue_;
      public float HighValue {
        get { return highValue_; }
        set {
          highValue_ = value;
        }
      }

      public const int NumBitsFieldNumber = 9;
      private int numBits_;
      public int NumBits {
        get { return numBits_; }
        set {
          numBits_ = value;
        }
      }

      public override bool Equals(object other) {
        return Equals(other as sendprop_t);
      }

      public bool Equals(sendprop_t other) {
        if (ReferenceEquals(other, null)) {
          return false;
        }
        if (ReferenceEquals(other, this)) {
          return true;
        }
        if (Type != other.Type) return false;
        if (VarName != other.VarName) return false;
        if (Flags != other.Flags) return false;
        if (Priority != other.Priority) return false;
        if (DtName != other.DtName) return false;
        if (NumElements != other.NumElements) return false;
        if (LowValue != other.LowValue) return false;
        if (HighValue != other.HighValue) return false;
        if (NumBits != other.NumBits) return false;
        return true;
      }

      public override int GetHashCode() {
        int hash = 1;
        if (Type != 0) hash ^= Type.GetHashCode();
        if (VarName.Length != 0) hash ^= VarName.GetHashCode();
        if (Flags != 0) hash ^= Flags.GetHashCode();
        if (Priority != 0) hash ^= Priority.GetHashCode();
        if (DtName.Length != 0) hash ^= DtName.GetHashCode();
        if (NumElements != 0) hash ^= NumElements.GetHashCode();
        if (LowValue != 0F) hash ^= LowValue.GetHashCode();
        if (HighValue != 0F) hash ^= HighValue.GetHashCode();
        if (NumBits != 0) hash ^= NumBits.GetHashCode();
        return hash;
      }

      public override string ToString() {
        return pb::JsonFormatter.Default.Format(this);
      }

      public void WriteTo(pb::CodedOutputStream output) {
        if (Type != 0) {
          output.WriteRawTag(8);
          output.WriteInt32(Type);
        }
        if (VarName.Length != 0) {
          output.WriteRawTag(18);
          output.WriteString(VarName);
        }
        if (Flags != 0) {
          output.WriteRawTag(24);
          output.WriteInt32(Flags);
        }
        if (Priority != 0) {
          output.WriteRawTag(32);
          output.WriteInt32(Priority);
        }
        if (DtName.Length != 0) {
          output.WriteRawTag(42);
          output.WriteString(DtName);
        }
        if (NumElements != 0) {
          output.WriteRawTag(48);
          output.WriteInt32(NumElements);
        }
        if (LowValue != 0F) {
          output.WriteRawTag(61);
          output.WriteFloat(LowValue);
        }
        if (HighValue != 0F) {
          output.WriteRawTag(69);
          output.WriteFloat(HighValue);
        }
        if (NumBits != 0) {
          output.WriteRawTag(72);
          output.WriteInt32(NumBits);
        }
      }

      public int CalculateSize() {
        int size = 0;
        if (Type != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(Type);
        }
        if (VarName.Length != 0) {
          size += 1 + pb::CodedOutputStream.ComputeStringSize(VarName);
        }
        if (Flags != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(Flags);
        }
        if (Priority != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(Priority);
        }
        if (DtName.Length != 0) {
          size += 1 + pb::CodedOutputStream.ComputeStringSize(DtName);
        }
        if (NumElements != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumElements);
        }
        if (LowValue != 0F) {
          size += 1 + 4;
        }
        if (HighValue != 0F) {
          size += 1 + 4;
        }
        if (NumBits != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumBits);
        }
        return size;
      }

      public void MergeFrom(sendprop_t other) {
        if (other == null) {
          return;
        }
        if (other.Type != 0) {
          Type = other.Type;
        }
        if (other.VarName.Length != 0) {
          VarName = other.VarName;
        }
        if (other.Flags != 0) {
          Flags = other.Flags;
        }
        if (other.Priority != 0) {
          Priority = other.Priority;
        }
        if (other.DtName.Length != 0) {
          DtName = other.DtName;
        }
        if (other.NumElements != 0) {
          NumElements = other.NumElements;
        }
        if (other.LowValue != 0F) {
          LowValue = other.LowValue;
        }
        if (other.HighValue != 0F) {
          HighValue = other.HighValue;
        }
        if (other.NumBits != 0) {
          NumBits = other.NumBits;
        }
      }

      public void MergeFrom(pb::CodedInputStream input) {
        uint tag;
        while ((tag = input.ReadTag()) != 0) {
          switch(tag) {
            default:
              input.SkipLastField();
              break;
            case 8: {
              Type = input.ReadInt32();
              break;
            }
            case 18: {
              VarName = input.ReadString();
              break;
            }
            case 24: {
              Flags = input.ReadInt32();
              break;
            }
            case 32: {
              Priority = input.ReadInt32();
              break;
            }
            case 42: {
              DtName = input.ReadString();
              break;
            }
            case 48: {
              NumElements = input.ReadInt32();
              break;
            }
            case 61: {
              LowValue = input.ReadFloat();
              break;
            }
            case 69: {
              HighValue = input.ReadFloat();
              break;
            }
            case 72: {
              NumBits = input.ReadInt32();
              break;
            }
          }
        }
      }

    }

  }
  #endregion

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_Print : pb::IMessage<CSVCMsg_Print> {
  private static readonly pb::MessageParser<CSVCMsg_Print> _parser = new pb::MessageParser<CSVCMsg_Print>(() => new CSVCMsg_Print());
  public static pb::MessageParser<CSVCMsg_Print> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[15]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_Print() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_Print(CSVCMsg_Print other) : this() {
    text_ = other.text_;
  }

  public CSVCMsg_Print Clone() {
    return new CSVCMsg_Print(this);
  }

  public const int TextFieldNumber = 1;
  private string text_ = "";
  public string Text {
    get { return text_; }
    set {
      text_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_Print);
  }

  public bool Equals(CSVCMsg_Print other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (Text != other.Text) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (Text.Length != 0) hash ^= Text.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (Text.Length != 0) {
      output.WriteRawTag(10);
      output.WriteString(Text);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (Text.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Text);
    }
    return size;
  }

  public void MergeFrom(CSVCMsg_Print other) {
    if (other == null) {
      return;
    }
    if (other.Text.Length != 0) {
      Text = other.Text;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 10: {
          Text = input.ReadString();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_SetPause : pb::IMessage<CSVCMsg_SetPause> {
  private static readonly pb::MessageParser<CSVCMsg_SetPause> _parser = new pb::MessageParser<CSVCMsg_SetPause>(() => new CSVCMsg_SetPause());
  public static pb::MessageParser<CSVCMsg_SetPause> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[16]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_SetPause() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_SetPause(CSVCMsg_SetPause other) : this() {
    paused_ = other.paused_;
  }

  public CSVCMsg_SetPause Clone() {
    return new CSVCMsg_SetPause(this);
  }

  public const int PausedFieldNumber = 1;
  private bool paused_;
  public bool Paused {
    get { return paused_; }
    set {
      paused_ = value;
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_SetPause);
  }

  public bool Equals(CSVCMsg_SetPause other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (Paused != other.Paused) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (Paused != false) hash ^= Paused.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (Paused != false) {
      output.WriteRawTag(8);
      output.WriteBool(Paused);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (Paused != false) {
      size += 1 + 1;
    }
    return size;
  }

  public void MergeFrom(CSVCMsg_SetPause other) {
    if (other == null) {
      return;
    }
    if (other.Paused != false) {
      Paused = other.Paused;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          Paused = input.ReadBool();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_SetView : pb::IMessage<CSVCMsg_SetView> {
  private static readonly pb::MessageParser<CSVCMsg_SetView> _parser = new pb::MessageParser<CSVCMsg_SetView>(() => new CSVCMsg_SetView());
  public static pb::MessageParser<CSVCMsg_SetView> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[17]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_SetView() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_SetView(CSVCMsg_SetView other) : this() {
    entityIndex_ = other.entityIndex_;
  }

  public CSVCMsg_SetView Clone() {
    return new CSVCMsg_SetView(this);
  }

  public const int EntityIndexFieldNumber = 1;
  private int entityIndex_;
  public int EntityIndex {
    get { return entityIndex_; }
    set {
      entityIndex_ = value;
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_SetView);
  }

  public bool Equals(CSVCMsg_SetView other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (EntityIndex != other.EntityIndex) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (EntityIndex != 0) hash ^= EntityIndex.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (EntityIndex != 0) {
      output.WriteRawTag(8);
      output.WriteInt32(EntityIndex);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (EntityIndex != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(EntityIndex);
    }
    return size;
  }

  public void MergeFrom(CSVCMsg_SetView other) {
    if (other == null) {
      return;
    }
    if (other.EntityIndex != 0) {
      EntityIndex = other.EntityIndex;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          EntityIndex = input.ReadInt32();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_CreateStringTable : pb::IMessage<CSVCMsg_CreateStringTable> {
  private static readonly pb::MessageParser<CSVCMsg_CreateStringTable> _parser = new pb::MessageParser<CSVCMsg_CreateStringTable>(() => new CSVCMsg_CreateStringTable());
  public static pb::MessageParser<CSVCMsg_CreateStringTable> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[18]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_CreateStringTable() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_CreateStringTable(CSVCMsg_CreateStringTable other) : this() {
    name_ = other.name_;
    maxEntries_ = other.maxEntries_;
    numEntries_ = other.numEntries_;
    userDataFixedSize_ = other.userDataFixedSize_;
    userDataSize_ = other.userDataSize_;
    userDataSizeBits_ = other.userDataSizeBits_;
    flags_ = other.flags_;
    stringData_ = other.stringData_;
  }

  public CSVCMsg_CreateStringTable Clone() {
    return new CSVCMsg_CreateStringTable(this);
  }

  public const int NameFieldNumber = 1;
  private string name_ = "";
  public string Name {
    get { return name_; }
    set {
      name_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public const int MaxEntriesFieldNumber = 2;
  private int maxEntries_;
  public int MaxEntries {
    get { return maxEntries_; }
    set {
      maxEntries_ = value;
    }
  }

  public const int NumEntriesFieldNumber = 3;
  private int numEntries_;
  public int NumEntries {
    get { return numEntries_; }
    set {
      numEntries_ = value;
    }
  }

  public const int UserDataFixedSizeFieldNumber = 4;
  private bool userDataFixedSize_;
  public bool UserDataFixedSize {
    get { return userDataFixedSize_; }
    set {
      userDataFixedSize_ = value;
    }
  }

  public const int UserDataSizeFieldNumber = 5;
  private int userDataSize_;
  public int UserDataSize {
    get { return userDataSize_; }
    set {
      userDataSize_ = value;
    }
  }

  public const int UserDataSizeBitsFieldNumber = 6;
  private int userDataSizeBits_;
  public int UserDataSizeBits {
    get { return userDataSizeBits_; }
    set {
      userDataSizeBits_ = value;
    }
  }

  public const int FlagsFieldNumber = 7;
  private int flags_;
  public int Flags {
    get { return flags_; }
    set {
      flags_ = value;
    }
  }

  public const int StringDataFieldNumber = 8;
  private pb::ByteString stringData_ = pb::ByteString.Empty;
  public pb::ByteString StringData {
    get { return stringData_; }
    set {
      stringData_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_CreateStringTable);
  }

  public bool Equals(CSVCMsg_CreateStringTable other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (Name != other.Name) return false;
    if (MaxEntries != other.MaxEntries) return false;
    if (NumEntries != other.NumEntries) return false;
    if (UserDataFixedSize != other.UserDataFixedSize) return false;
    if (UserDataSize != other.UserDataSize) return false;
    if (UserDataSizeBits != other.UserDataSizeBits) return false;
    if (Flags != other.Flags) return false;
    if (StringData != other.StringData) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (Name.Length != 0) hash ^= Name.GetHashCode();
    if (MaxEntries != 0) hash ^= MaxEntries.GetHashCode();
    if (NumEntries != 0) hash ^= NumEntries.GetHashCode();
    if (UserDataFixedSize != false) hash ^= UserDataFixedSize.GetHashCode();
    if (UserDataSize != 0) hash ^= UserDataSize.GetHashCode();
    if (UserDataSizeBits != 0) hash ^= UserDataSizeBits.GetHashCode();
    if (Flags != 0) hash ^= Flags.GetHashCode();
    if (StringData.Length != 0) hash ^= StringData.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (Name.Length != 0) {
      output.WriteRawTag(10);
      output.WriteString(Name);
    }
    if (MaxEntries != 0) {
      output.WriteRawTag(16);
      output.WriteInt32(MaxEntries);
    }
    if (NumEntries != 0) {
      output.WriteRawTag(24);
      output.WriteInt32(NumEntries);
    }
    if (UserDataFixedSize != false) {
      output.WriteRawTag(32);
      output.WriteBool(UserDataFixedSize);
    }
    if (UserDataSize != 0) {
      output.WriteRawTag(40);
      output.WriteInt32(UserDataSize);
    }
    if (UserDataSizeBits != 0) {
      output.WriteRawTag(48);
      output.WriteInt32(UserDataSizeBits);
    }
    if (Flags != 0) {
      output.WriteRawTag(56);
      output.WriteInt32(Flags);
    }
    if (StringData.Length != 0) {
      output.WriteRawTag(66);
      output.WriteBytes(StringData);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (Name.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
    }
    if (MaxEntries != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxEntries);
    }
    if (NumEntries != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumEntries);
    }
    if (UserDataFixedSize != false) {
      size += 1 + 1;
    }
    if (UserDataSize != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(UserDataSize);
    }
    if (UserDataSizeBits != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(UserDataSizeBits);
    }
    if (Flags != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(Flags);
    }
    if (StringData.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeBytesSize(StringData);
    }
    return size;
  }

  public void MergeFrom(CSVCMsg_CreateStringTable other) {
    if (other == null) {
      return;
    }
    if (other.Name.Length != 0) {
      Name = other.Name;
    }
    if (other.MaxEntries != 0) {
      MaxEntries = other.MaxEntries;
    }
    if (other.NumEntries != 0) {
      NumEntries = other.NumEntries;
    }
    if (other.UserDataFixedSize != false) {
      UserDataFixedSize = other.UserDataFixedSize;
    }
    if (other.UserDataSize != 0) {
      UserDataSize = other.UserDataSize;
    }
    if (other.UserDataSizeBits != 0) {
      UserDataSizeBits = other.UserDataSizeBits;
    }
    if (other.Flags != 0) {
      Flags = other.Flags;
    }
    if (other.StringData.Length != 0) {
      StringData = other.StringData;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 10: {
          Name = input.ReadString();
          break;
        }
        case 16: {
          MaxEntries = input.ReadInt32();
          break;
        }
        case 24: {
          NumEntries = input.ReadInt32();
          break;
        }
        case 32: {
          UserDataFixedSize = input.ReadBool();
          break;
        }
        case 40: {
          UserDataSize = input.ReadInt32();
          break;
        }
        case 48: {
          UserDataSizeBits = input.ReadInt32();
          break;
        }
        case 56: {
          Flags = input.ReadInt32();
          break;
        }
        case 66: {
          StringData = input.ReadBytes();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_UpdateStringTable : pb::IMessage<CSVCMsg_UpdateStringTable> {
  private static readonly pb::MessageParser<CSVCMsg_UpdateStringTable> _parser = new pb::MessageParser<CSVCMsg_UpdateStringTable>(() => new CSVCMsg_UpdateStringTable());
  public static pb::MessageParser<CSVCMsg_UpdateStringTable> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[19]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_UpdateStringTable() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_UpdateStringTable(CSVCMsg_UpdateStringTable other) : this() {
    tableId_ = other.tableId_;
    numChangedEntries_ = other.numChangedEntries_;
    stringData_ = other.stringData_;
  }

  public CSVCMsg_UpdateStringTable Clone() {
    return new CSVCMsg_UpdateStringTable(this);
  }

  public const int TableIdFieldNumber = 1;
  private int tableId_;
  public int TableId {
    get { return tableId_; }
    set {
      tableId_ = value;
    }
  }

  public const int NumChangedEntriesFieldNumber = 2;
  private int numChangedEntries_;
  public int NumChangedEntries {
    get { return numChangedEntries_; }
    set {
      numChangedEntries_ = value;
    }
  }

  public const int StringDataFieldNumber = 3;
  private pb::ByteString stringData_ = pb::ByteString.Empty;
  public pb::ByteString StringData {
    get { return stringData_; }
    set {
      stringData_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_UpdateStringTable);
  }

  public bool Equals(CSVCMsg_UpdateStringTable other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (TableId != other.TableId) return false;
    if (NumChangedEntries != other.NumChangedEntries) return false;
    if (StringData != other.StringData) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (TableId != 0) hash ^= TableId.GetHashCode();
    if (NumChangedEntries != 0) hash ^= NumChangedEntries.GetHashCode();
    if (StringData.Length != 0) hash ^= StringData.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (TableId != 0) {
      output.WriteRawTag(8);
      output.WriteInt32(TableId);
    }
    if (NumChangedEntries != 0) {
      output.WriteRawTag(16);
      output.WriteInt32(NumChangedEntries);
    }
    if (StringData.Length != 0) {
      output.WriteRawTag(26);
      output.WriteBytes(StringData);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (TableId != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(TableId);
    }
    if (NumChangedEntries != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumChangedEntries);
    }
    if (StringData.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeBytesSize(StringData);
    }
    return size;
  }

  public void MergeFrom(CSVCMsg_UpdateStringTable other) {
    if (other == null) {
      return;
    }
    if (other.TableId != 0) {
      TableId = other.TableId;
    }
    if (other.NumChangedEntries != 0) {
      NumChangedEntries = other.NumChangedEntries;
    }
    if (other.StringData.Length != 0) {
      StringData = other.StringData;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          TableId = input.ReadInt32();
          break;
        }
        case 16: {
          NumChangedEntries = input.ReadInt32();
          break;
        }
        case 26: {
          StringData = input.ReadBytes();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_VoiceInit : pb::IMessage<CSVCMsg_VoiceInit> {
  private static readonly pb::MessageParser<CSVCMsg_VoiceInit> _parser = new pb::MessageParser<CSVCMsg_VoiceInit>(() => new CSVCMsg_VoiceInit());
  public static pb::MessageParser<CSVCMsg_VoiceInit> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[20]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_VoiceInit() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_VoiceInit(CSVCMsg_VoiceInit other) : this() {
    quality_ = other.quality_;
    codec_ = other.codec_;
  }

  public CSVCMsg_VoiceInit Clone() {
    return new CSVCMsg_VoiceInit(this);
  }

  public const int QualityFieldNumber = 1;
  private int quality_;
  public int Quality {
    get { return quality_; }
    set {
      quality_ = value;
    }
  }

  public const int CodecFieldNumber = 2;
  private string codec_ = "";
  public string Codec {
    get { return codec_; }
    set {
      codec_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_VoiceInit);
  }

  public bool Equals(CSVCMsg_VoiceInit other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (Quality != other.Quality) return false;
    if (Codec != other.Codec) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (Quality != 0) hash ^= Quality.GetHashCode();
    if (Codec.Length != 0) hash ^= Codec.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (Quality != 0) {
      output.WriteRawTag(8);
      output.WriteInt32(Quality);
    }
    if (Codec.Length != 0) {
      output.WriteRawTag(18);
      output.WriteString(Codec);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (Quality != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(Quality);
    }
    if (Codec.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Codec);
    }
    return size;
  }

  public void MergeFrom(CSVCMsg_VoiceInit other) {
    if (other == null) {
      return;
    }
    if (other.Quality != 0) {
      Quality = other.Quality;
    }
    if (other.Codec.Length != 0) {
      Codec = other.Codec;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          Quality = input.ReadInt32();
          break;
        }
        case 18: {
          Codec = input.ReadString();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_VoiceData : pb::IMessage<CSVCMsg_VoiceData> {
  private static readonly pb::MessageParser<CSVCMsg_VoiceData> _parser = new pb::MessageParser<CSVCMsg_VoiceData>(() => new CSVCMsg_VoiceData());
  public static pb::MessageParser<CSVCMsg_VoiceData> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[21]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_VoiceData() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_VoiceData(CSVCMsg_VoiceData other) : this() {
    client_ = other.client_;
    proximity_ = other.proximity_;
    xuid_ = other.xuid_;
    audibleMask_ = other.audibleMask_;
    voiceData_ = other.voiceData_;
  }

  public CSVCMsg_VoiceData Clone() {
    return new CSVCMsg_VoiceData(this);
  }

  public const int ClientFieldNumber = 1;
  private int client_;
  public int Client {
    get { return client_; }
    set {
      client_ = value;
    }
  }

  public const int ProximityFieldNumber = 2;
  private bool proximity_;
  public bool Proximity {
    get { return proximity_; }
    set {
      proximity_ = value;
    }
  }

  public const int XuidFieldNumber = 3;
  private ulong xuid_;
  public ulong Xuid {
    get { return xuid_; }
    set {
      xuid_ = value;
    }
  }

  public const int AudibleMaskFieldNumber = 4;
  private int audibleMask_;
  public int AudibleMask {
    get { return audibleMask_; }
    set {
      audibleMask_ = value;
    }
  }

  public const int VoiceDataFieldNumber = 5;
  private pb::ByteString voiceData_ = pb::ByteString.Empty;
  public pb::ByteString VoiceData {
    get { return voiceData_; }
    set {
      voiceData_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_VoiceData);
  }

  public bool Equals(CSVCMsg_VoiceData other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (Client != other.Client) return false;
    if (Proximity != other.Proximity) return false;
    if (Xuid != other.Xuid) return false;
    if (AudibleMask != other.AudibleMask) return false;
    if (VoiceData != other.VoiceData) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (Client != 0) hash ^= Client.GetHashCode();
    if (Proximity != false) hash ^= Proximity.GetHashCode();
    if (Xuid != 0UL) hash ^= Xuid.GetHashCode();
    if (AudibleMask != 0) hash ^= AudibleMask.GetHashCode();
    if (VoiceData.Length != 0) hash ^= VoiceData.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (Client != 0) {
      output.WriteRawTag(8);
      output.WriteInt32(Client);
    }
    if (Proximity != false) {
      output.WriteRawTag(16);
      output.WriteBool(Proximity);
    }
    if (Xuid != 0UL) {
      output.WriteRawTag(25);
      output.WriteFixed64(Xuid);
    }
    if (AudibleMask != 0) {
      output.WriteRawTag(32);
      output.WriteInt32(AudibleMask);
    }
    if (VoiceData.Length != 0) {
      output.WriteRawTag(42);
      output.WriteBytes(VoiceData);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (Client != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(Client);
    }
    if (Proximity != false) {
      size += 1 + 1;
    }
    if (Xuid != 0UL) {
      size += 1 + 8;
    }
    if (AudibleMask != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(AudibleMask);
    }
    if (VoiceData.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeBytesSize(VoiceData);
    }
    return size;
  }

  public void MergeFrom(CSVCMsg_VoiceData other) {
    if (other == null) {
      return;
    }
    if (other.Client != 0) {
      Client = other.Client;
    }
    if (other.Proximity != false) {
      Proximity = other.Proximity;
    }
    if (other.Xuid != 0UL) {
      Xuid = other.Xuid;
    }
    if (other.AudibleMask != 0) {
      AudibleMask = other.AudibleMask;
    }
    if (other.VoiceData.Length != 0) {
      VoiceData = other.VoiceData;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          Client = input.ReadInt32();
          break;
        }
        case 16: {
          Proximity = input.ReadBool();
          break;
        }
        case 25: {
          Xuid = input.ReadFixed64();
          break;
        }
        case 32: {
          AudibleMask = input.ReadInt32();
          break;
        }
        case 42: {
          VoiceData = input.ReadBytes();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_FixAngle : pb::IMessage<CSVCMsg_FixAngle> {
  private static readonly pb::MessageParser<CSVCMsg_FixAngle> _parser = new pb::MessageParser<CSVCMsg_FixAngle>(() => new CSVCMsg_FixAngle());
  public static pb::MessageParser<CSVCMsg_FixAngle> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[22]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_FixAngle() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_FixAngle(CSVCMsg_FixAngle other) : this() {
    relative_ = other.relative_;
    Angle = other.angle_ != null ? other.Angle.Clone() : null;
  }

  public CSVCMsg_FixAngle Clone() {
    return new CSVCMsg_FixAngle(this);
  }

  public const int RelativeFieldNumber = 1;
  private bool relative_;
  public bool Relative {
    get { return relative_; }
    set {
      relative_ = value;
    }
  }

  public const int AngleFieldNumber = 2;
  private global::CMsgQAngle angle_;
  public global::CMsgQAngle Angle {
    get { return angle_; }
    set {
      angle_ = value;
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_FixAngle);
  }

  public bool Equals(CSVCMsg_FixAngle other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (Relative != other.Relative) return false;
    if (!object.Equals(Angle, other.Angle)) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (Relative != false) hash ^= Relative.GetHashCode();
    if (angle_ != null) hash ^= Angle.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (Relative != false) {
      output.WriteRawTag(8);
      output.WriteBool(Relative);
    }
    if (angle_ != null) {
      output.WriteRawTag(18);
      output.WriteMessage(Angle);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (Relative != false) {
      size += 1 + 1;
    }
    if (angle_ != null) {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Angle);
    }
    return size;
  }

  public void MergeFrom(CSVCMsg_FixAngle other) {
    if (other == null) {
      return;
    }
    if (other.Relative != false) {
      Relative = other.Relative;
    }
    if (other.angle_ != null) {
      if (angle_ == null) {
        angle_ = new global::CMsgQAngle();
      }
      Angle.MergeFrom(other.Angle);
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          Relative = input.ReadBool();
          break;
        }
        case 18: {
          if (angle_ == null) {
            angle_ = new global::CMsgQAngle();
          }
          input.ReadMessage(angle_);
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_CrosshairAngle : pb::IMessage<CSVCMsg_CrosshairAngle> {
  private static readonly pb::MessageParser<CSVCMsg_CrosshairAngle> _parser = new pb::MessageParser<CSVCMsg_CrosshairAngle>(() => new CSVCMsg_CrosshairAngle());
  public static pb::MessageParser<CSVCMsg_CrosshairAngle> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[23]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_CrosshairAngle() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_CrosshairAngle(CSVCMsg_CrosshairAngle other) : this() {
    Angle = other.angle_ != null ? other.Angle.Clone() : null;
  }

  public CSVCMsg_CrosshairAngle Clone() {
    return new CSVCMsg_CrosshairAngle(this);
  }

  public const int AngleFieldNumber = 1;
  private global::CMsgQAngle angle_;
  public global::CMsgQAngle Angle {
    get { return angle_; }
    set {
      angle_ = value;
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_CrosshairAngle);
  }

  public bool Equals(CSVCMsg_CrosshairAngle other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (!object.Equals(Angle, other.Angle)) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (angle_ != null) hash ^= Angle.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (angle_ != null) {
      output.WriteRawTag(10);
      output.WriteMessage(Angle);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (angle_ != null) {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Angle);
    }
    return size;
  }

  public void MergeFrom(CSVCMsg_CrosshairAngle other) {
    if (other == null) {
      return;
    }
    if (other.angle_ != null) {
      if (angle_ == null) {
        angle_ = new global::CMsgQAngle();
      }
      Angle.MergeFrom(other.Angle);
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 10: {
          if (angle_ == null) {
            angle_ = new global::CMsgQAngle();
          }
          input.ReadMessage(angle_);
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_Prefetch : pb::IMessage<CSVCMsg_Prefetch> {
  private static readonly pb::MessageParser<CSVCMsg_Prefetch> _parser = new pb::MessageParser<CSVCMsg_Prefetch>(() => new CSVCMsg_Prefetch());
  public static pb::MessageParser<CSVCMsg_Prefetch> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[24]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_Prefetch() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_Prefetch(CSVCMsg_Prefetch other) : this() {
    soundIndex_ = other.soundIndex_;
  }

  public CSVCMsg_Prefetch Clone() {
    return new CSVCMsg_Prefetch(this);
  }

  public const int SoundIndexFieldNumber = 1;
  private int soundIndex_;
  public int SoundIndex {
    get { return soundIndex_; }
    set {
      soundIndex_ = value;
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_Prefetch);
  }

  public bool Equals(CSVCMsg_Prefetch other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (SoundIndex != other.SoundIndex) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (SoundIndex != 0) hash ^= SoundIndex.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (SoundIndex != 0) {
      output.WriteRawTag(8);
      output.WriteInt32(SoundIndex);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (SoundIndex != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(SoundIndex);
    }
    return size;
  }

  public void MergeFrom(CSVCMsg_Prefetch other) {
    if (other == null) {
      return;
    }
    if (other.SoundIndex != 0) {
      SoundIndex = other.SoundIndex;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          SoundIndex = input.ReadInt32();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_BSPDecal : pb::IMessage<CSVCMsg_BSPDecal> {
  private static readonly pb::MessageParser<CSVCMsg_BSPDecal> _parser = new pb::MessageParser<CSVCMsg_BSPDecal>(() => new CSVCMsg_BSPDecal());
  public static pb::MessageParser<CSVCMsg_BSPDecal> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[25]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_BSPDecal() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_BSPDecal(CSVCMsg_BSPDecal other) : this() {
    Pos = other.pos_ != null ? other.Pos.Clone() : null;
    decalTextureIndex_ = other.decalTextureIndex_;
    entityIndex_ = other.entityIndex_;
    modelIndex_ = other.modelIndex_;
    lowPriority_ = other.lowPriority_;
  }

  public CSVCMsg_BSPDecal Clone() {
    return new CSVCMsg_BSPDecal(this);
  }

  public const int PosFieldNumber = 1;
  private global::CMsgVector pos_;
  public global::CMsgVector Pos {
    get { return pos_; }
    set {
      pos_ = value;
    }
  }

  public const int DecalTextureIndexFieldNumber = 2;
  private int decalTextureIndex_;
  public int DecalTextureIndex {
    get { return decalTextureIndex_; }
    set {
      decalTextureIndex_ = value;
    }
  }

  public const int EntityIndexFieldNumber = 3;
  private int entityIndex_;
  public int EntityIndex {
    get { return entityIndex_; }
    set {
      entityIndex_ = value;
    }
  }

  public const int ModelIndexFieldNumber = 4;
  private int modelIndex_;
  public int ModelIndex {
    get { return modelIndex_; }
    set {
      modelIndex_ = value;
    }
  }

  public const int LowPriorityFieldNumber = 5;
  private bool lowPriority_;
  public bool LowPriority {
    get { return lowPriority_; }
    set {
      lowPriority_ = value;
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_BSPDecal);
  }

  public bool Equals(CSVCMsg_BSPDecal other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (!object.Equals(Pos, other.Pos)) return false;
    if (DecalTextureIndex != other.DecalTextureIndex) return false;
    if (EntityIndex != other.EntityIndex) return false;
    if (ModelIndex != other.ModelIndex) return false;
    if (LowPriority != other.LowPriority) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (pos_ != null) hash ^= Pos.GetHashCode();
    if (DecalTextureIndex != 0) hash ^= DecalTextureIndex.GetHashCode();
    if (EntityIndex != 0) hash ^= EntityIndex.GetHashCode();
    if (ModelIndex != 0) hash ^= ModelIndex.GetHashCode();
    if (LowPriority != false) hash ^= LowPriority.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (pos_ != null) {
      output.WriteRawTag(10);
      output.WriteMessage(Pos);
    }
    if (DecalTextureIndex != 0) {
      output.WriteRawTag(16);
      output.WriteInt32(DecalTextureIndex);
    }
    if (EntityIndex != 0) {
      output.WriteRawTag(24);
      output.WriteInt32(EntityIndex);
    }
    if (ModelIndex != 0) {
      output.WriteRawTag(32);
      output.WriteInt32(ModelIndex);
    }
    if (LowPriority != false) {
      output.WriteRawTag(40);
      output.WriteBool(LowPriority);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (pos_ != null) {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Pos);
    }
    if (DecalTextureIndex != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(DecalTextureIndex);
    }
    if (EntityIndex != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(EntityIndex);
    }
    if (ModelIndex != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(ModelIndex);
    }
    if (LowPriority != false) {
      size += 1 + 1;
    }
    return size;
  }

  public void MergeFrom(CSVCMsg_BSPDecal other) {
    if (other == null) {
      return;
    }
    if (other.pos_ != null) {
      if (pos_ == null) {
        pos_ = new global::CMsgVector();
      }
      Pos.MergeFrom(other.Pos);
    }
    if (other.DecalTextureIndex != 0) {
      DecalTextureIndex = other.DecalTextureIndex;
    }
    if (other.EntityIndex != 0) {
      EntityIndex = other.EntityIndex;
    }
    if (other.ModelIndex != 0) {
      ModelIndex = other.ModelIndex;
    }
    if (other.LowPriority != false) {
      LowPriority = other.LowPriority;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 10: {
          if (pos_ == null) {
            pos_ = new global::CMsgVector();
          }
          input.ReadMessage(pos_);
          break;
        }
        case 16: {
          DecalTextureIndex = input.ReadInt32();
          break;
        }
        case 24: {
          EntityIndex = input.ReadInt32();
          break;
        }
        case 32: {
          ModelIndex = input.ReadInt32();
          break;
        }
        case 40: {
          LowPriority = input.ReadBool();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_GetCvarValue : pb::IMessage<CSVCMsg_GetCvarValue> {
  private static readonly pb::MessageParser<CSVCMsg_GetCvarValue> _parser = new pb::MessageParser<CSVCMsg_GetCvarValue>(() => new CSVCMsg_GetCvarValue());
  public static pb::MessageParser<CSVCMsg_GetCvarValue> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[26]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_GetCvarValue() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_GetCvarValue(CSVCMsg_GetCvarValue other) : this() {
    cookie_ = other.cookie_;
    cvarName_ = other.cvarName_;
  }

  public CSVCMsg_GetCvarValue Clone() {
    return new CSVCMsg_GetCvarValue(this);
  }

  public const int CookieFieldNumber = 1;
  private int cookie_;
  public int Cookie {
    get { return cookie_; }
    set {
      cookie_ = value;
    }
  }

  public const int CvarNameFieldNumber = 2;
  private string cvarName_ = "";
  public string CvarName {
    get { return cvarName_; }
    set {
      cvarName_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_GetCvarValue);
  }

  public bool Equals(CSVCMsg_GetCvarValue other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (Cookie != other.Cookie) return false;
    if (CvarName != other.CvarName) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (Cookie != 0) hash ^= Cookie.GetHashCode();
    if (CvarName.Length != 0) hash ^= CvarName.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (Cookie != 0) {
      output.WriteRawTag(8);
      output.WriteInt32(Cookie);
    }
    if (CvarName.Length != 0) {
      output.WriteRawTag(18);
      output.WriteString(CvarName);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (Cookie != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(Cookie);
    }
    if (CvarName.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(CvarName);
    }
    return size;
  }

  public void MergeFrom(CSVCMsg_GetCvarValue other) {
    if (other == null) {
      return;
    }
    if (other.Cookie != 0) {
      Cookie = other.Cookie;
    }
    if (other.CvarName.Length != 0) {
      CvarName = other.CvarName;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          Cookie = input.ReadInt32();
          break;
        }
        case 18: {
          CvarName = input.ReadString();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_Menu : pb::IMessage<CSVCMsg_Menu> {
  private static readonly pb::MessageParser<CSVCMsg_Menu> _parser = new pb::MessageParser<CSVCMsg_Menu>(() => new CSVCMsg_Menu());
  public static pb::MessageParser<CSVCMsg_Menu> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[27]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_Menu() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_Menu(CSVCMsg_Menu other) : this() {
    dialogType_ = other.dialogType_;
    menuKeyValues_ = other.menuKeyValues_;
  }

  public CSVCMsg_Menu Clone() {
    return new CSVCMsg_Menu(this);
  }

  public const int DialogTypeFieldNumber = 1;
  private int dialogType_;
  public int DialogType {
    get { return dialogType_; }
    set {
      dialogType_ = value;
    }
  }

  public const int MenuKeyValuesFieldNumber = 2;
  private pb::ByteString menuKeyValues_ = pb::ByteString.Empty;
  public pb::ByteString MenuKeyValues {
    get { return menuKeyValues_; }
    set {
      menuKeyValues_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_Menu);
  }

  public bool Equals(CSVCMsg_Menu other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (DialogType != other.DialogType) return false;
    if (MenuKeyValues != other.MenuKeyValues) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (DialogType != 0) hash ^= DialogType.GetHashCode();
    if (MenuKeyValues.Length != 0) hash ^= MenuKeyValues.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (DialogType != 0) {
      output.WriteRawTag(8);
      output.WriteInt32(DialogType);
    }
    if (MenuKeyValues.Length != 0) {
      output.WriteRawTag(18);
      output.WriteBytes(MenuKeyValues);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (DialogType != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(DialogType);
    }
    if (MenuKeyValues.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeBytesSize(MenuKeyValues);
    }
    return size;
  }

  public void MergeFrom(CSVCMsg_Menu other) {
    if (other == null) {
      return;
    }
    if (other.DialogType != 0) {
      DialogType = other.DialogType;
    }
    if (other.MenuKeyValues.Length != 0) {
      MenuKeyValues = other.MenuKeyValues;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          DialogType = input.ReadInt32();
          break;
        }
        case 18: {
          MenuKeyValues = input.ReadBytes();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_UserMessage : pb::IMessage<CSVCMsg_UserMessage> {
  private static readonly pb::MessageParser<CSVCMsg_UserMessage> _parser = new pb::MessageParser<CSVCMsg_UserMessage>(() => new CSVCMsg_UserMessage());
  public static pb::MessageParser<CSVCMsg_UserMessage> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[28]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_UserMessage() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_UserMessage(CSVCMsg_UserMessage other) : this() {
    msgType_ = other.msgType_;
    msgData_ = other.msgData_;
  }

  public CSVCMsg_UserMessage Clone() {
    return new CSVCMsg_UserMessage(this);
  }

  public const int MsgTypeFieldNumber = 1;
  private int msgType_;
  public int MsgType {
    get { return msgType_; }
    set {
      msgType_ = value;
    }
  }

  public const int MsgDataFieldNumber = 2;
  private pb::ByteString msgData_ = pb::ByteString.Empty;
  public pb::ByteString MsgData {
    get { return msgData_; }
    set {
      msgData_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_UserMessage);
  }

  public bool Equals(CSVCMsg_UserMessage other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (MsgType != other.MsgType) return false;
    if (MsgData != other.MsgData) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (MsgType != 0) hash ^= MsgType.GetHashCode();
    if (MsgData.Length != 0) hash ^= MsgData.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (MsgType != 0) {
      output.WriteRawTag(8);
      output.WriteInt32(MsgType);
    }
    if (MsgData.Length != 0) {
      output.WriteRawTag(18);
      output.WriteBytes(MsgData);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (MsgType != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(MsgType);
    }
    if (MsgData.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeBytesSize(MsgData);
    }
    return size;
  }

  public void MergeFrom(CSVCMsg_UserMessage other) {
    if (other == null) {
      return;
    }
    if (other.MsgType != 0) {
      MsgType = other.MsgType;
    }
    if (other.MsgData.Length != 0) {
      MsgData = other.MsgData;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          MsgType = input.ReadInt32();
          break;
        }
        case 18: {
          MsgData = input.ReadBytes();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_GameEvent : pb::IMessage<CSVCMsg_GameEvent> {
  private static readonly pb::MessageParser<CSVCMsg_GameEvent> _parser = new pb::MessageParser<CSVCMsg_GameEvent>(() => new CSVCMsg_GameEvent());
  public static pb::MessageParser<CSVCMsg_GameEvent> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[29]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_GameEvent() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_GameEvent(CSVCMsg_GameEvent other) : this() {
    eventName_ = other.eventName_;
    eventid_ = other.eventid_;
    keys_ = other.keys_.Clone();
  }

  public CSVCMsg_GameEvent Clone() {
    return new CSVCMsg_GameEvent(this);
  }

  public const int EventNameFieldNumber = 1;
  private string eventName_ = "";
  public string EventName {
    get { return eventName_; }
    set {
      eventName_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public const int EventidFieldNumber = 2;
  private int eventid_;
  public int Eventid {
    get { return eventid_; }
    set {
      eventid_ = value;
    }
  }

  public const int KeysFieldNumber = 3;
  private static readonly pb::FieldCodec<global::CSVCMsg_GameEvent.Types.key_t> _repeated_keys_codec
      = pb::FieldCodec.ForMessage(26, global::CSVCMsg_GameEvent.Types.key_t.Parser);
  private readonly pbc::RepeatedField<global::CSVCMsg_GameEvent.Types.key_t> keys_ = new pbc::RepeatedField<global::CSVCMsg_GameEvent.Types.key_t>();
  public pbc::RepeatedField<global::CSVCMsg_GameEvent.Types.key_t> Keys {
    get { return keys_; }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_GameEvent);
  }

  public bool Equals(CSVCMsg_GameEvent other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (EventName != other.EventName) return false;
    if (Eventid != other.Eventid) return false;
    if(!keys_.Equals(other.keys_)) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (EventName.Length != 0) hash ^= EventName.GetHashCode();
    if (Eventid != 0) hash ^= Eventid.GetHashCode();
    hash ^= keys_.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (EventName.Length != 0) {
      output.WriteRawTag(10);
      output.WriteString(EventName);
    }
    if (Eventid != 0) {
      output.WriteRawTag(16);
      output.WriteInt32(Eventid);
    }
    keys_.WriteTo(output, _repeated_keys_codec);
  }

  public int CalculateSize() {
    int size = 0;
    if (EventName.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(EventName);
    }
    if (Eventid != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(Eventid);
    }
    size += keys_.CalculateSize(_repeated_keys_codec);
    return size;
  }

  public void MergeFrom(CSVCMsg_GameEvent other) {
    if (other == null) {
      return;
    }
    if (other.EventName.Length != 0) {
      EventName = other.EventName;
    }
    if (other.Eventid != 0) {
      Eventid = other.Eventid;
    }
    keys_.Add(other.keys_);
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 10: {
          EventName = input.ReadString();
          break;
        }
        case 16: {
          Eventid = input.ReadInt32();
          break;
        }
        case 26: {
          keys_.AddEntriesFrom(input, _repeated_keys_codec);
          break;
        }
      }
    }
  }

  #region Nested types
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Types {
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class key_t : pb::IMessage<key_t> {
      private static readonly pb::MessageParser<key_t> _parser = new pb::MessageParser<key_t>(() => new key_t());
      public static pb::MessageParser<key_t> Parser { get { return _parser; } }

      public static pbr::MessageDescriptor Descriptor {
        get { return global::CSVCMsg_GameEvent.Descriptor.NestedTypes[0]; }
      }

      pbr::MessageDescriptor pb::IMessage.Descriptor {
        get { return Descriptor; }
      }

      public key_t() {
        OnConstruction();
      }

      partial void OnConstruction();

      public key_t(key_t other) : this() {
        type_ = other.type_;
        valString_ = other.valString_;
        valFloat_ = other.valFloat_;
        valLong_ = other.valLong_;
        valShort_ = other.valShort_;
        valByte_ = other.valByte_;
        valBool_ = other.valBool_;
        valUint64_ = other.valUint64_;
        valWstring_ = other.valWstring_;
      }

      public key_t Clone() {
        return new key_t(this);
      }

      public const int TypeFieldNumber = 1;
      private int type_;
      public int Type {
        get { return type_; }
        set {
          type_ = value;
        }
      }

      public const int ValStringFieldNumber = 2;
      private string valString_ = "";
      public string ValString {
        get { return valString_; }
        set {
          valString_ = pb::Preconditions.CheckNotNull(value, "value");
        }
      }

      public const int ValFloatFieldNumber = 3;
      private float valFloat_;
      public float ValFloat {
        get { return valFloat_; }
        set {
          valFloat_ = value;
        }
      }

      public const int ValLongFieldNumber = 4;
      private int valLong_;
      public int ValLong {
        get { return valLong_; }
        set {
          valLong_ = value;
        }
      }

      public const int ValShortFieldNumber = 5;
      private int valShort_;
      public int ValShort {
        get { return valShort_; }
        set {
          valShort_ = value;
        }
      }

      public const int ValByteFieldNumber = 6;
      private int valByte_;
      public int ValByte {
        get { return valByte_; }
        set {
          valByte_ = value;
        }
      }

      public const int ValBoolFieldNumber = 7;
      private bool valBool_;
      public bool ValBool {
        get { return valBool_; }
        set {
          valBool_ = value;
        }
      }

      public const int ValUint64FieldNumber = 8;
      private ulong valUint64_;
      public ulong ValUint64 {
        get { return valUint64_; }
        set {
          valUint64_ = value;
        }
      }

      public const int ValWstringFieldNumber = 9;
      private pb::ByteString valWstring_ = pb::ByteString.Empty;
      public pb::ByteString ValWstring {
        get { return valWstring_; }
        set {
          valWstring_ = pb::Preconditions.CheckNotNull(value, "value");
        }
      }

      public override bool Equals(object other) {
        return Equals(other as key_t);
      }

      public bool Equals(key_t other) {
        if (ReferenceEquals(other, null)) {
          return false;
        }
        if (ReferenceEquals(other, this)) {
          return true;
        }
        if (Type != other.Type) return false;
        if (ValString != other.ValString) return false;
        if (ValFloat != other.ValFloat) return false;
        if (ValLong != other.ValLong) return false;
        if (ValShort != other.ValShort) return false;
        if (ValByte != other.ValByte) return false;
        if (ValBool != other.ValBool) return false;
        if (ValUint64 != other.ValUint64) return false;
        if (ValWstring != other.ValWstring) return false;
        return true;
      }

      public override int GetHashCode() {
        int hash = 1;
        if (Type != 0) hash ^= Type.GetHashCode();
        if (ValString.Length != 0) hash ^= ValString.GetHashCode();
        if (ValFloat != 0F) hash ^= ValFloat.GetHashCode();
        if (ValLong != 0) hash ^= ValLong.GetHashCode();
        if (ValShort != 0) hash ^= ValShort.GetHashCode();
        if (ValByte != 0) hash ^= ValByte.GetHashCode();
        if (ValBool != false) hash ^= ValBool.GetHashCode();
        if (ValUint64 != 0UL) hash ^= ValUint64.GetHashCode();
        if (ValWstring.Length != 0) hash ^= ValWstring.GetHashCode();
        return hash;
      }

      public override string ToString() {
        return pb::JsonFormatter.Default.Format(this);
      }

      public void WriteTo(pb::CodedOutputStream output) {
        if (Type != 0) {
          output.WriteRawTag(8);
          output.WriteInt32(Type);
        }
        if (ValString.Length != 0) {
          output.WriteRawTag(18);
          output.WriteString(ValString);
        }
        if (ValFloat != 0F) {
          output.WriteRawTag(29);
          output.WriteFloat(ValFloat);
        }
        if (ValLong != 0) {
          output.WriteRawTag(32);
          output.WriteInt32(ValLong);
        }
        if (ValShort != 0) {
          output.WriteRawTag(40);
          output.WriteInt32(ValShort);
        }
        if (ValByte != 0) {
          output.WriteRawTag(48);
          output.WriteInt32(ValByte);
        }
        if (ValBool != false) {
          output.WriteRawTag(56);
          output.WriteBool(ValBool);
        }
        if (ValUint64 != 0UL) {
          output.WriteRawTag(64);
          output.WriteUInt64(ValUint64);
        }
        if (ValWstring.Length != 0) {
          output.WriteRawTag(74);
          output.WriteBytes(ValWstring);
        }
      }

      public int CalculateSize() {
        int size = 0;
        if (Type != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(Type);
        }
        if (ValString.Length != 0) {
          size += 1 + pb::CodedOutputStream.ComputeStringSize(ValString);
        }
        if (ValFloat != 0F) {
          size += 1 + 4;
        }
        if (ValLong != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(ValLong);
        }
        if (ValShort != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(ValShort);
        }
        if (ValByte != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(ValByte);
        }
        if (ValBool != false) {
          size += 1 + 1;
        }
        if (ValUint64 != 0UL) {
          size += 1 + pb::CodedOutputStream.ComputeUInt64Size(ValUint64);
        }
        if (ValWstring.Length != 0) {
          size += 1 + pb::CodedOutputStream.ComputeBytesSize(ValWstring);
        }
        return size;
      }

      public void MergeFrom(key_t other) {
        if (other == null) {
          return;
        }
        if (other.Type != 0) {
          Type = other.Type;
        }
        if (other.ValString.Length != 0) {
          ValString = other.ValString;
        }
        if (other.ValFloat != 0F) {
          ValFloat = other.ValFloat;
        }
        if (other.ValLong != 0) {
          ValLong = other.ValLong;
        }
        if (other.ValShort != 0) {
          ValShort = other.ValShort;
        }
        if (other.ValByte != 0) {
          ValByte = other.ValByte;
        }
        if (other.ValBool != false) {
          ValBool = other.ValBool;
        }
        if (other.ValUint64 != 0UL) {
          ValUint64 = other.ValUint64;
        }
        if (other.ValWstring.Length != 0) {
          ValWstring = other.ValWstring;
        }
      }

      public void MergeFrom(pb::CodedInputStream input) {
        uint tag;
        while ((tag = input.ReadTag()) != 0) {
          switch(tag) {
            default:
              input.SkipLastField();
              break;
            case 8: {
              Type = input.ReadInt32();
              break;
            }
            case 18: {
              ValString = input.ReadString();
              break;
            }
            case 29: {
              ValFloat = input.ReadFloat();
              break;
            }
            case 32: {
              ValLong = input.ReadInt32();
              break;
            }
            case 40: {
              ValShort = input.ReadInt32();
              break;
            }
            case 48: {
              ValByte = input.ReadInt32();
              break;
            }
            case 56: {
              ValBool = input.ReadBool();
              break;
            }
            case 64: {
              ValUint64 = input.ReadUInt64();
              break;
            }
            case 74: {
              ValWstring = input.ReadBytes();
              break;
            }
          }
        }
      }

    }

  }
  #endregion

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_GameEventList : pb::IMessage<CSVCMsg_GameEventList> {
  private static readonly pb::MessageParser<CSVCMsg_GameEventList> _parser = new pb::MessageParser<CSVCMsg_GameEventList>(() => new CSVCMsg_GameEventList());
  public static pb::MessageParser<CSVCMsg_GameEventList> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[30]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_GameEventList() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_GameEventList(CSVCMsg_GameEventList other) : this() {
    descriptors_ = other.descriptors_.Clone();
  }

  public CSVCMsg_GameEventList Clone() {
    return new CSVCMsg_GameEventList(this);
  }

  public const int DescriptorsFieldNumber = 1;
  private static readonly pb::FieldCodec<global::CSVCMsg_GameEventList.Types.descriptor_t> _repeated_descriptors_codec
      = pb::FieldCodec.ForMessage(10, global::CSVCMsg_GameEventList.Types.descriptor_t.Parser);
  private readonly pbc::RepeatedField<global::CSVCMsg_GameEventList.Types.descriptor_t> descriptors_ = new pbc::RepeatedField<global::CSVCMsg_GameEventList.Types.descriptor_t>();
  public pbc::RepeatedField<global::CSVCMsg_GameEventList.Types.descriptor_t> Descriptors {
    get { return descriptors_; }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_GameEventList);
  }

  public bool Equals(CSVCMsg_GameEventList other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if(!descriptors_.Equals(other.descriptors_)) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    hash ^= descriptors_.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    descriptors_.WriteTo(output, _repeated_descriptors_codec);
  }

  public int CalculateSize() {
    int size = 0;
    size += descriptors_.CalculateSize(_repeated_descriptors_codec);
    return size;
  }

  public void MergeFrom(CSVCMsg_GameEventList other) {
    if (other == null) {
      return;
    }
    descriptors_.Add(other.descriptors_);
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 10: {
          descriptors_.AddEntriesFrom(input, _repeated_descriptors_codec);
          break;
        }
      }
    }
  }

  #region Nested types
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Types {
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class key_t : pb::IMessage<key_t> {
      private static readonly pb::MessageParser<key_t> _parser = new pb::MessageParser<key_t>(() => new key_t());
      public static pb::MessageParser<key_t> Parser { get { return _parser; } }

      public static pbr::MessageDescriptor Descriptor {
        get { return global::CSVCMsg_GameEventList.Descriptor.NestedTypes[0]; }
      }

      pbr::MessageDescriptor pb::IMessage.Descriptor {
        get { return Descriptor; }
      }

      public key_t() {
        OnConstruction();
      }

      partial void OnConstruction();

      public key_t(key_t other) : this() {
        type_ = other.type_;
        name_ = other.name_;
      }

      public key_t Clone() {
        return new key_t(this);
      }

      public const int TypeFieldNumber = 1;
      private int type_;
      public int Type {
        get { return type_; }
        set {
          type_ = value;
        }
      }

      public const int NameFieldNumber = 2;
      private string name_ = "";
      public string Name {
        get { return name_; }
        set {
          name_ = pb::Preconditions.CheckNotNull(value, "value");
        }
      }

      public override bool Equals(object other) {
        return Equals(other as key_t);
      }

      public bool Equals(key_t other) {
        if (ReferenceEquals(other, null)) {
          return false;
        }
        if (ReferenceEquals(other, this)) {
          return true;
        }
        if (Type != other.Type) return false;
        if (Name != other.Name) return false;
        return true;
      }

      public override int GetHashCode() {
        int hash = 1;
        if (Type != 0) hash ^= Type.GetHashCode();
        if (Name.Length != 0) hash ^= Name.GetHashCode();
        return hash;
      }

      public override string ToString() {
        return pb::JsonFormatter.Default.Format(this);
      }

      public void WriteTo(pb::CodedOutputStream output) {
        if (Type != 0) {
          output.WriteRawTag(8);
          output.WriteInt32(Type);
        }
        if (Name.Length != 0) {
          output.WriteRawTag(18);
          output.WriteString(Name);
        }
      }

      public int CalculateSize() {
        int size = 0;
        if (Type != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(Type);
        }
        if (Name.Length != 0) {
          size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
        }
        return size;
      }

      public void MergeFrom(key_t other) {
        if (other == null) {
          return;
        }
        if (other.Type != 0) {
          Type = other.Type;
        }
        if (other.Name.Length != 0) {
          Name = other.Name;
        }
      }

      public void MergeFrom(pb::CodedInputStream input) {
        uint tag;
        while ((tag = input.ReadTag()) != 0) {
          switch(tag) {
            default:
              input.SkipLastField();
              break;
            case 8: {
              Type = input.ReadInt32();
              break;
            }
            case 18: {
              Name = input.ReadString();
              break;
            }
          }
        }
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class descriptor_t : pb::IMessage<descriptor_t> {
      private static readonly pb::MessageParser<descriptor_t> _parser = new pb::MessageParser<descriptor_t>(() => new descriptor_t());
      public static pb::MessageParser<descriptor_t> Parser { get { return _parser; } }

      public static pbr::MessageDescriptor Descriptor {
        get { return global::CSVCMsg_GameEventList.Descriptor.NestedTypes[1]; }
      }

      pbr::MessageDescriptor pb::IMessage.Descriptor {
        get { return Descriptor; }
      }

      public descriptor_t() {
        OnConstruction();
      }

      partial void OnConstruction();

      public descriptor_t(descriptor_t other) : this() {
        eventid_ = other.eventid_;
        name_ = other.name_;
        keys_ = other.keys_.Clone();
      }

      public descriptor_t Clone() {
        return new descriptor_t(this);
      }

      public const int EventidFieldNumber = 1;
      private int eventid_;
      public int Eventid {
        get { return eventid_; }
        set {
          eventid_ = value;
        }
      }

      public const int NameFieldNumber = 2;
      private string name_ = "";
      public string Name {
        get { return name_; }
        set {
          name_ = pb::Preconditions.CheckNotNull(value, "value");
        }
      }

      public const int KeysFieldNumber = 3;
      private static readonly pb::FieldCodec<global::CSVCMsg_GameEventList.Types.key_t> _repeated_keys_codec
          = pb::FieldCodec.ForMessage(26, global::CSVCMsg_GameEventList.Types.key_t.Parser);
      private readonly pbc::RepeatedField<global::CSVCMsg_GameEventList.Types.key_t> keys_ = new pbc::RepeatedField<global::CSVCMsg_GameEventList.Types.key_t>();
      public pbc::RepeatedField<global::CSVCMsg_GameEventList.Types.key_t> Keys {
        get { return keys_; }
      }

      public override bool Equals(object other) {
        return Equals(other as descriptor_t);
      }

      public bool Equals(descriptor_t other) {
        if (ReferenceEquals(other, null)) {
          return false;
        }
        if (ReferenceEquals(other, this)) {
          return true;
        }
        if (Eventid != other.Eventid) return false;
        if (Name != other.Name) return false;
        if(!keys_.Equals(other.keys_)) return false;
        return true;
      }

      public override int GetHashCode() {
        int hash = 1;
        if (Eventid != 0) hash ^= Eventid.GetHashCode();
        if (Name.Length != 0) hash ^= Name.GetHashCode();
        hash ^= keys_.GetHashCode();
        return hash;
      }

      public override string ToString() {
        return pb::JsonFormatter.Default.Format(this);
      }

      public void WriteTo(pb::CodedOutputStream output) {
        if (Eventid != 0) {
          output.WriteRawTag(8);
          output.WriteInt32(Eventid);
        }
        if (Name.Length != 0) {
          output.WriteRawTag(18);
          output.WriteString(Name);
        }
        keys_.WriteTo(output, _repeated_keys_codec);
      }

      public int CalculateSize() {
        int size = 0;
        if (Eventid != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(Eventid);
        }
        if (Name.Length != 0) {
          size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
        }
        size += keys_.CalculateSize(_repeated_keys_codec);
        return size;
      }

      public void MergeFrom(descriptor_t other) {
        if (other == null) {
          return;
        }
        if (other.Eventid != 0) {
          Eventid = other.Eventid;
        }
        if (other.Name.Length != 0) {
          Name = other.Name;
        }
        keys_.Add(other.keys_);
      }

      public void MergeFrom(pb::CodedInputStream input) {
        uint tag;
        while ((tag = input.ReadTag()) != 0) {
          switch(tag) {
            default:
              input.SkipLastField();
              break;
            case 8: {
              Eventid = input.ReadInt32();
              break;
            }
            case 18: {
              Name = input.ReadString();
              break;
            }
            case 26: {
              keys_.AddEntriesFrom(input, _repeated_keys_codec);
              break;
            }
          }
        }
      }

    }

  }
  #endregion

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_TempEntities : pb::IMessage<CSVCMsg_TempEntities> {
  private static readonly pb::MessageParser<CSVCMsg_TempEntities> _parser = new pb::MessageParser<CSVCMsg_TempEntities>(() => new CSVCMsg_TempEntities());
  public static pb::MessageParser<CSVCMsg_TempEntities> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[31]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_TempEntities() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_TempEntities(CSVCMsg_TempEntities other) : this() {
    reliable_ = other.reliable_;
    numEntries_ = other.numEntries_;
    entityData_ = other.entityData_;
  }

  public CSVCMsg_TempEntities Clone() {
    return new CSVCMsg_TempEntities(this);
  }

  public const int ReliableFieldNumber = 1;
  private bool reliable_;
  public bool Reliable {
    get { return reliable_; }
    set {
      reliable_ = value;
    }
  }

  public const int NumEntriesFieldNumber = 2;
  private int numEntries_;
  public int NumEntries {
    get { return numEntries_; }
    set {
      numEntries_ = value;
    }
  }

  public const int EntityDataFieldNumber = 3;
  private pb::ByteString entityData_ = pb::ByteString.Empty;
  public pb::ByteString EntityData {
    get { return entityData_; }
    set {
      entityData_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_TempEntities);
  }

  public bool Equals(CSVCMsg_TempEntities other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (Reliable != other.Reliable) return false;
    if (NumEntries != other.NumEntries) return false;
    if (EntityData != other.EntityData) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (Reliable != false) hash ^= Reliable.GetHashCode();
    if (NumEntries != 0) hash ^= NumEntries.GetHashCode();
    if (EntityData.Length != 0) hash ^= EntityData.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (Reliable != false) {
      output.WriteRawTag(8);
      output.WriteBool(Reliable);
    }
    if (NumEntries != 0) {
      output.WriteRawTag(16);
      output.WriteInt32(NumEntries);
    }
    if (EntityData.Length != 0) {
      output.WriteRawTag(26);
      output.WriteBytes(EntityData);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (Reliable != false) {
      size += 1 + 1;
    }
    if (NumEntries != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumEntries);
    }
    if (EntityData.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeBytesSize(EntityData);
    }
    return size;
  }

  public void MergeFrom(CSVCMsg_TempEntities other) {
    if (other == null) {
      return;
    }
    if (other.Reliable != false) {
      Reliable = other.Reliable;
    }
    if (other.NumEntries != 0) {
      NumEntries = other.NumEntries;
    }
    if (other.EntityData.Length != 0) {
      EntityData = other.EntityData;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          Reliable = input.ReadBool();
          break;
        }
        case 16: {
          NumEntries = input.ReadInt32();
          break;
        }
        case 26: {
          EntityData = input.ReadBytes();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_PacketEntities : pb::IMessage<CSVCMsg_PacketEntities> {
  private static readonly pb::MessageParser<CSVCMsg_PacketEntities> _parser = new pb::MessageParser<CSVCMsg_PacketEntities>(() => new CSVCMsg_PacketEntities());
  public static pb::MessageParser<CSVCMsg_PacketEntities> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[32]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_PacketEntities() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_PacketEntities(CSVCMsg_PacketEntities other) : this() {
    maxEntries_ = other.maxEntries_;
    updatedEntries_ = other.updatedEntries_;
    isDelta_ = other.isDelta_;
    updateBaseline_ = other.updateBaseline_;
    baseline_ = other.baseline_;
    deltaFrom_ = other.deltaFrom_;
    entityData_ = other.entityData_;
  }

  public CSVCMsg_PacketEntities Clone() {
    return new CSVCMsg_PacketEntities(this);
  }

  public const int MaxEntriesFieldNumber = 1;
  private int maxEntries_;
  public int MaxEntries {
    get { return maxEntries_; }
    set {
      maxEntries_ = value;
    }
  }

  public const int UpdatedEntriesFieldNumber = 2;
  private int updatedEntries_;
  public int UpdatedEntries {
    get { return updatedEntries_; }
    set {
      updatedEntries_ = value;
    }
  }

  public const int IsDeltaFieldNumber = 3;
  private bool isDelta_;
  public bool IsDelta {
    get { return isDelta_; }
    set {
      isDelta_ = value;
    }
  }

  public const int UpdateBaselineFieldNumber = 4;
  private bool updateBaseline_;
  public bool UpdateBaseline {
    get { return updateBaseline_; }
    set {
      updateBaseline_ = value;
    }
  }

  public const int BaselineFieldNumber = 5;
  private int baseline_;
  public int Baseline {
    get { return baseline_; }
    set {
      baseline_ = value;
    }
  }

  public const int DeltaFromFieldNumber = 6;
  private int deltaFrom_;
  public int DeltaFrom {
    get { return deltaFrom_; }
    set {
      deltaFrom_ = value;
    }
  }

  public const int EntityDataFieldNumber = 7;
  private pb::ByteString entityData_ = pb::ByteString.Empty;
  public pb::ByteString EntityData {
    get { return entityData_; }
    set {
      entityData_ = pb::Preconditions.CheckNotNull(value, "value");
    }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_PacketEntities);
  }

  public bool Equals(CSVCMsg_PacketEntities other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (MaxEntries != other.MaxEntries) return false;
    if (UpdatedEntries != other.UpdatedEntries) return false;
    if (IsDelta != other.IsDelta) return false;
    if (UpdateBaseline != other.UpdateBaseline) return false;
    if (Baseline != other.Baseline) return false;
    if (DeltaFrom != other.DeltaFrom) return false;
    if (EntityData != other.EntityData) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (MaxEntries != 0) hash ^= MaxEntries.GetHashCode();
    if (UpdatedEntries != 0) hash ^= UpdatedEntries.GetHashCode();
    if (IsDelta != false) hash ^= IsDelta.GetHashCode();
    if (UpdateBaseline != false) hash ^= UpdateBaseline.GetHashCode();
    if (Baseline != 0) hash ^= Baseline.GetHashCode();
    if (DeltaFrom != 0) hash ^= DeltaFrom.GetHashCode();
    if (EntityData.Length != 0) hash ^= EntityData.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (MaxEntries != 0) {
      output.WriteRawTag(8);
      output.WriteInt32(MaxEntries);
    }
    if (UpdatedEntries != 0) {
      output.WriteRawTag(16);
      output.WriteInt32(UpdatedEntries);
    }
    if (IsDelta != false) {
      output.WriteRawTag(24);
      output.WriteBool(IsDelta);
    }
    if (UpdateBaseline != false) {
      output.WriteRawTag(32);
      output.WriteBool(UpdateBaseline);
    }
    if (Baseline != 0) {
      output.WriteRawTag(40);
      output.WriteInt32(Baseline);
    }
    if (DeltaFrom != 0) {
      output.WriteRawTag(48);
      output.WriteInt32(DeltaFrom);
    }
    if (EntityData.Length != 0) {
      output.WriteRawTag(58);
      output.WriteBytes(EntityData);
    }
  }

  public int CalculateSize() {
    int size = 0;
    if (MaxEntries != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxEntries);
    }
    if (UpdatedEntries != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(UpdatedEntries);
    }
    if (IsDelta != false) {
      size += 1 + 1;
    }
    if (UpdateBaseline != false) {
      size += 1 + 1;
    }
    if (Baseline != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(Baseline);
    }
    if (DeltaFrom != 0) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(DeltaFrom);
    }
    if (EntityData.Length != 0) {
      size += 1 + pb::CodedOutputStream.ComputeBytesSize(EntityData);
    }
    return size;
  }

  public void MergeFrom(CSVCMsg_PacketEntities other) {
    if (other == null) {
      return;
    }
    if (other.MaxEntries != 0) {
      MaxEntries = other.MaxEntries;
    }
    if (other.UpdatedEntries != 0) {
      UpdatedEntries = other.UpdatedEntries;
    }
    if (other.IsDelta != false) {
      IsDelta = other.IsDelta;
    }
    if (other.UpdateBaseline != false) {
      UpdateBaseline = other.UpdateBaseline;
    }
    if (other.Baseline != 0) {
      Baseline = other.Baseline;
    }
    if (other.DeltaFrom != 0) {
      DeltaFrom = other.DeltaFrom;
    }
    if (other.EntityData.Length != 0) {
      EntityData = other.EntityData;
    }
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          MaxEntries = input.ReadInt32();
          break;
        }
        case 16: {
          UpdatedEntries = input.ReadInt32();
          break;
        }
        case 24: {
          IsDelta = input.ReadBool();
          break;
        }
        case 32: {
          UpdateBaseline = input.ReadBool();
          break;
        }
        case 40: {
          Baseline = input.ReadInt32();
          break;
        }
        case 48: {
          DeltaFrom = input.ReadInt32();
          break;
        }
        case 58: {
          EntityData = input.ReadBytes();
          break;
        }
      }
    }
  }

}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_Sounds : pb::IMessage<CSVCMsg_Sounds> {
  private static readonly pb::MessageParser<CSVCMsg_Sounds> _parser = new pb::MessageParser<CSVCMsg_Sounds>(() => new CSVCMsg_Sounds());
  public static pb::MessageParser<CSVCMsg_Sounds> Parser { get { return _parser; } }

  public static pbr::MessageDescriptor Descriptor {
    get { return global::NetmessagesPublic.Descriptor.MessageTypes[33]; }
  }

  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  public CSVCMsg_Sounds() {
    OnConstruction();
  }

  partial void OnConstruction();

  public CSVCMsg_Sounds(CSVCMsg_Sounds other) : this() {
    reliableSound_ = other.reliableSound_;
    sounds_ = other.sounds_.Clone();
  }

  public CSVCMsg_Sounds Clone() {
    return new CSVCMsg_Sounds(this);
  }

  public const int ReliableSoundFieldNumber = 1;
  private bool reliableSound_;
  public bool ReliableSound {
    get { return reliableSound_; }
    set {
      reliableSound_ = value;
    }
  }

  public const int SoundsFieldNumber = 2;
  private static readonly pb::FieldCodec<global::CSVCMsg_Sounds.Types.sounddata_t> _repeated_sounds_codec
      = pb::FieldCodec.ForMessage(18, global::CSVCMsg_Sounds.Types.sounddata_t.Parser);
  private readonly pbc::RepeatedField<global::CSVCMsg_Sounds.Types.sounddata_t> sounds_ = new pbc::RepeatedField<global::CSVCMsg_Sounds.Types.sounddata_t>();
  public pbc::RepeatedField<global::CSVCMsg_Sounds.Types.sounddata_t> Sounds {
    get { return sounds_; }
  }

  public override bool Equals(object other) {
    return Equals(other as CSVCMsg_Sounds);
  }

  public bool Equals(CSVCMsg_Sounds other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (ReliableSound != other.ReliableSound) return false;
    if(!sounds_.Equals(other.sounds_)) return false;
    return true;
  }

  public override int GetHashCode() {
    int hash = 1;
    if (ReliableSound != false) hash ^= ReliableSound.GetHashCode();
    hash ^= sounds_.GetHashCode();
    return hash;
  }

  public override string ToString() {
    return pb::JsonFormatter.Default.Format(this);
  }

  public void WriteTo(pb::CodedOutputStream output) {
    if (ReliableSound != false) {
      output.WriteRawTag(8);
      output.WriteBool(ReliableSound);
    }
    sounds_.WriteTo(output, _repeated_sounds_codec);
  }

  public int CalculateSize() {
    int size = 0;
    if (ReliableSound != false) {
      size += 1 + 1;
    }
    size += sounds_.CalculateSize(_repeated_sounds_codec);
    return size;
  }

  public void MergeFrom(CSVCMsg_Sounds other) {
    if (other == null) {
      return;
    }
    if (other.ReliableSound != false) {
      ReliableSound = other.ReliableSound;
    }
    sounds_.Add(other.sounds_);
  }

  public void MergeFrom(pb::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          input.SkipLastField();
          break;
        case 8: {
          ReliableSound = input.ReadBool();
          break;
        }
        case 18: {
          sounds_.AddEntriesFrom(input, _repeated_sounds_codec);
          break;
        }
      }
    }
  }

  #region Nested types
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Types {
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class sounddata_t : pb::IMessage<sounddata_t> {
      private static readonly pb::MessageParser<sounddata_t> _parser = new pb::MessageParser<sounddata_t>(() => new sounddata_t());
      public static pb::MessageParser<sounddata_t> Parser { get { return _parser; } }

      public static pbr::MessageDescriptor Descriptor {
        get { return global::CSVCMsg_Sounds.Descriptor.NestedTypes[0]; }
      }

      pbr::MessageDescriptor pb::IMessage.Descriptor {
        get { return Descriptor; }
      }

      public sounddata_t() {
        OnConstruction();
      }

      partial void OnConstruction();

      public sounddata_t(sounddata_t other) : this() {
        originX_ = other.originX_;
        originY_ = other.originY_;
        originZ_ = other.originZ_;
        volume_ = other.volume_;
        delayValue_ = other.delayValue_;
        sequenceNumber_ = other.sequenceNumber_;
        entityIndex_ = other.entityIndex_;
        channel_ = other.channel_;
        pitch_ = other.pitch_;
        flags_ = other.flags_;
        soundNum_ = other.soundNum_;
        soundNumHandle_ = other.soundNumHandle_;
        speakerEntity_ = other.speakerEntity_;
        randomSeed_ = other.randomSeed_;
        soundLevel_ = other.soundLevel_;
        isSentence_ = other.isSentence_;
        isAmbient_ = other.isAmbient_;
      }

      public sounddata_t Clone() {
        return new sounddata_t(this);
      }

      public const int OriginXFieldNumber = 1;
      private int originX_;
      public int OriginX {
        get { return originX_; }
        set {
          originX_ = value;
        }
      }

      public const int OriginYFieldNumber = 2;
      private int originY_;
      public int OriginY {
        get { return originY_; }
        set {
          originY_ = value;
        }
      }

      public const int OriginZFieldNumber = 3;
      private int originZ_;
      public int OriginZ {
        get { return originZ_; }
        set {
          originZ_ = value;
        }
      }

      public const int VolumeFieldNumber = 4;
      private uint volume_;
      public uint Volume {
        get { return volume_; }
        set {
          volume_ = value;
        }
      }

      public const int DelayValueFieldNumber = 5;
      private float delayValue_;
      public float DelayValue {
        get { return delayValue_; }
        set {
          delayValue_ = value;
        }
      }

      public const int SequenceNumberFieldNumber = 6;
      private int sequenceNumber_;
      public int SequenceNumber {
        get { return sequenceNumber_; }
        set {
          sequenceNumber_ = value;
        }
      }

      public const int EntityIndexFieldNumber = 7;
      private int entityIndex_;
      public int EntityIndex {
        get { return entityIndex_; }
        set {
          entityIndex_ = value;
        }
      }

      public const int ChannelFieldNumber = 8;
      private int channel_;
      public int Channel {
        get { return channel_; }
        set {
          channel_ = value;
        }
      }

      public const int PitchFieldNumber = 9;
      private int pitch_;
      public int Pitch {
        get { return pitch_; }
        set {
          pitch_ = value;
        }
      }

      public const int FlagsFieldNumber = 10;
      private int flags_;
      public int Flags {
        get { return flags_; }
        set {
          flags_ = value;
        }
      }

      public const int SoundNumFieldNumber = 11;
      private uint soundNum_;
      public uint SoundNum {
        get { return soundNum_; }
        set {
          soundNum_ = value;
        }
      }

      public const int SoundNumHandleFieldNumber = 12;
      private uint soundNumHandle_;
      public uint SoundNumHandle {
        get { return soundNumHandle_; }
        set {
          soundNumHandle_ = value;
        }
      }

      public const int SpeakerEntityFieldNumber = 13;
      private int speakerEntity_;
      public int SpeakerEntity {
        get { return speakerEntity_; }
        set {
          speakerEntity_ = value;
        }
      }

      public const int RandomSeedFieldNumber = 14;
      private int randomSeed_;
      public int RandomSeed {
        get { return randomSeed_; }
        set {
          randomSeed_ = value;
        }
      }

      public const int SoundLevelFieldNumber = 15;
      private int soundLevel_;
      public int SoundLevel {
        get { return soundLevel_; }
        set {
          soundLevel_ = value;
        }
      }

      public const int IsSentenceFieldNumber = 16;
      private bool isSentence_;
      public bool IsSentence {
        get { return isSentence_; }
        set {
          isSentence_ = value;
        }
      }

      public const int IsAmbientFieldNumber = 17;
      private bool isAmbient_;
      public bool IsAmbient {
        get { return isAmbient_; }
        set {
          isAmbient_ = value;
        }
      }

      public override bool Equals(object other) {
        return Equals(other as sounddata_t);
      }

      public bool Equals(sounddata_t other) {
        if (ReferenceEquals(other, null)) {
          return false;
        }
        if (ReferenceEquals(other, this)) {
          return true;
        }
        if (OriginX != other.OriginX) return false;
        if (OriginY != other.OriginY) return false;
        if (OriginZ != other.OriginZ) return false;
        if (Volume != other.Volume) return false;
        if (DelayValue != other.DelayValue) return false;
        if (SequenceNumber != other.SequenceNumber) return false;
        if (EntityIndex != other.EntityIndex) return false;
        if (Channel != other.Channel) return false;
        if (Pitch != other.Pitch) return false;
        if (Flags != other.Flags) return false;
        if (SoundNum != other.SoundNum) return false;
        if (SoundNumHandle != other.SoundNumHandle) return false;
        if (SpeakerEntity != other.SpeakerEntity) return false;
        if (RandomSeed != other.RandomSeed) return false;
        if (SoundLevel != other.SoundLevel) return false;
        if (IsSentence != other.IsSentence) return false;
        if (IsAmbient != other.IsAmbient) return false;
        return true;
      }

      public override int GetHashCode() {
        int hash = 1;
        if (OriginX != 0) hash ^= OriginX.GetHashCode();
        if (OriginY != 0) hash ^= OriginY.GetHashCode();
        if (OriginZ != 0) hash ^= OriginZ.GetHashCode();
        if (Volume != 0) hash ^= Volume.GetHashCode();
        if (DelayValue != 0F) hash ^= DelayValue.GetHashCode();
        if (SequenceNumber != 0) hash ^= SequenceNumber.GetHashCode();
        if (EntityIndex != 0) hash ^= EntityIndex.GetHashCode();
        if (Channel != 0) hash ^= Channel.GetHashCode();
        if (Pitch != 0) hash ^= Pitch.GetHashCode();
        if (Flags != 0) hash ^= Flags.GetHashCode();
        if (SoundNum != 0) hash ^= SoundNum.GetHashCode();
        if (SoundNumHandle != 0) hash ^= SoundNumHandle.GetHashCode();
        if (SpeakerEntity != 0) hash ^= SpeakerEntity.GetHashCode();
        if (RandomSeed != 0) hash ^= RandomSeed.GetHashCode();
        if (SoundLevel != 0) hash ^= SoundLevel.GetHashCode();
        if (IsSentence != false) hash ^= IsSentence.GetHashCode();
        if (IsAmbient != false) hash ^= IsAmbient.GetHashCode();
        return hash;
      }

      public override string ToString() {
        return pb::JsonFormatter.Default.Format(this);
      }

      public void WriteTo(pb::CodedOutputStream output) {
        if (OriginX != 0) {
          output.WriteRawTag(8);
          output.WriteSInt32(OriginX);
        }
        if (OriginY != 0) {
          output.WriteRawTag(16);
          output.WriteSInt32(OriginY);
        }
        if (OriginZ != 0) {
          output.WriteRawTag(24);
          output.WriteSInt32(OriginZ);
        }
        if (Volume != 0) {
          output.WriteRawTag(32);
          output.WriteUInt32(Volume);
        }
        if (DelayValue != 0F) {
          output.WriteRawTag(45);
          output.WriteFloat(DelayValue);
        }
        if (SequenceNumber != 0) {
          output.WriteRawTag(48);
          output.WriteInt32(SequenceNumber);
        }
        if (EntityIndex != 0) {
          output.WriteRawTag(56);
          output.WriteInt32(EntityIndex);
        }
        if (Channel != 0) {
          output.WriteRawTag(64);
          output.WriteInt32(Channel);
        }
        if (Pitch != 0) {
          output.WriteRawTag(72);
          output.WriteInt32(Pitch);
        }
        if (Flags != 0) {
          output.WriteRawTag(80);
          output.WriteInt32(Flags);
        }
        if (SoundNum != 0) {
          output.WriteRawTag(88);
          output.WriteUInt32(SoundNum);
        }
        if (SoundNumHandle != 0) {
          output.WriteRawTag(101);
          output.WriteFixed32(SoundNumHandle);
        }
        if (SpeakerEntity != 0) {
          output.WriteRawTag(104);
          output.WriteInt32(SpeakerEntity);
        }
        if (RandomSeed != 0) {
          output.WriteRawTag(112);
          output.WriteInt32(RandomSeed);
        }
        if (SoundLevel != 0) {
          output.WriteRawTag(120);
          output.WriteInt32(SoundLevel);
        }
        if (IsSentence != false) {
          output.WriteRawTag(128, 1);
          output.WriteBool(IsSentence);
        }
        if (IsAmbient != false) {
          output.WriteRawTag(136, 1);
          output.WriteBool(IsAmbient);
        }
      }

      public int CalculateSize() {
        int size = 0;
        if (OriginX != 0) {
          size += 1 + pb::CodedOutputStream.ComputeSInt32Size(OriginX);
        }
        if (OriginY != 0) {
          size += 1 + pb::CodedOutputStream.ComputeSInt32Size(OriginY);
        }
        if (OriginZ != 0) {
          size += 1 + pb::CodedOutputStream.ComputeSInt32Size(OriginZ);
        }
        if (Volume != 0) {
          size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Volume);
        }
        if (DelayValue != 0F) {
          size += 1 + 4;
        }
        if (SequenceNumber != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(SequenceNumber);
        }
        if (EntityIndex != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(EntityIndex);
        }
        if (Channel != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(Channel);
        }
        if (Pitch != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(Pitch);
        }
        if (Flags != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(Flags);
        }
        if (SoundNum != 0) {
          size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SoundNum);
        }
        if (SoundNumHandle != 0) {
          size += 1 + 4;
        }
        if (SpeakerEntity != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(SpeakerEntity);
        }
        if (RandomSeed != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(RandomSeed);
        }
        if (SoundLevel != 0) {
          size += 1 + pb::CodedOutputStream.ComputeInt32Size(SoundLevel);
        }
        if (IsSentence != false) {
          size += 2 + 1;
        }
        if (IsAmbient != false) {
          size += 2 + 1;
        }
        return size;
      }

      public void MergeFrom(sounddata_t other) {
        if (other == null) {
          return;
        }
        if (other.OriginX != 0) {
          OriginX = other.OriginX;
        }
        if (other.OriginY != 0) {
          OriginY = other.OriginY;
        }
        if (other.OriginZ != 0) {
          OriginZ = other.OriginZ;
        }
        if (other.Volume != 0) {
          Volume = other.Volume;
        }
        if (other.DelayValue != 0F) {
          DelayValue = other.DelayValue;
        }
        if (other.SequenceNumber != 0) {
          SequenceNumber = other.SequenceNumber;
        }
        if (other.EntityIndex != 0) {
          EntityIndex = other.EntityIndex;
        }
        if (other.Channel != 0) {
          Channel = other.Channel;
        }
        if (other.Pitch != 0) {
          Pitch = other.Pitch;
        }
        if (other.Flags != 0) {
          Flags = other.Flags;
        }
        if (other.SoundNum != 0) {
          SoundNum = other.SoundNum;
        }
        if (other.SoundNumHandle != 0) {
          SoundNumHandle = other.SoundNumHandle;
        }
        if (other.SpeakerEntity != 0) {
          SpeakerEntity = other.SpeakerEntity;
        }
        if (other.RandomSeed != 0) {
          RandomSeed = other.RandomSeed;
        }
        if (other.SoundLevel != 0) {
          SoundLevel = other.SoundLevel;
        }
        if (other.IsSentence != false) {
          IsSentence = other.IsSentence;
        }
        if (other.IsAmbient != false) {
          IsAmbient = other.IsAmbient;
        }
      }

      public void MergeFrom(pb::CodedInputStream input) {
        uint tag;
        while ((tag = input.ReadTag()) != 0) {
          switch(tag) {
            default:
              input.SkipLastField();
              break;
            case 8: {
              OriginX = input.ReadSInt32();
              break;
            }
            case 16: {
              OriginY = input.ReadSInt32();
              break;
            }
            case 24: {
              OriginZ = input.ReadSInt32();
              break;
            }
            case 32: {
              Volume = input.ReadUInt32();
              break;
            }
            case 45: {
              DelayValue = input.ReadFloat();
              break;
            }
            case 48: {
              SequenceNumber = input.ReadInt32();
              break;
            }
            case 56: {
              EntityIndex = input.ReadInt32();
              break;
            }
            case 64: {
              Channel = input.ReadInt32();
              break;
            }
            case 72: {
              Pitch = input.ReadInt32();
              break;
            }
            case 80: {
              Flags = input.ReadInt32();
              break;
            }
            case 88: {
              SoundNum = input.ReadUInt32();
              break;
            }
            case 101: {
              SoundNumHandle = input.ReadFixed32();
              break;
            }
            case 104: {
              SpeakerEntity = input.ReadInt32();
              break;
            }
            case 112: {
              RandomSeed = input.ReadInt32();
              break;
            }
            case 120: {
              SoundLevel = input.ReadInt32();
              break;
            }
            case 128: {
              IsSentence = input.ReadBool();
              break;
            }
            case 136: {
              IsAmbient = input.ReadBool();
              break;
            }
          }
        }
      }

    }

  }
  #endregion

}

#endregion


#endregion Designer generated code
